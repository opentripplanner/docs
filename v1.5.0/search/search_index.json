{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OpenTripPlanner This documentation is targeted primarily at the OTP development community and more technical users. For high-level information about the project, please visit www.opentripplanner.org OpenTripPlanner (OTP) is an open source multi-modal trip planner, which runs on Linux, Mac, Windows, or potentially any platform with a Java virtual machine. OTP is released under the LGPL license . The code is under active development with a variety of deployments around the world. If you want to get started right away running your own OTP instance, the best place to start is the Basic Tutorial page. Versions of this documentation OTP Master - Latest release OTP dev-1.x - OTP 1 development branch OTP dev-2.x - OTP 2 development branch External Technical Documentation Some technical documentation is generated automatically from the OTP source code and available from other locations. The Javadoc describes OTP's Java classes and their methods for software developers who call or change this code directly. The Web Service API documents describe the endpoints OTP exposes via its HTTP interface. It is generated automatically by Enunciate from comments in the source code, so may be incomplete or overly verbose in places. These documents are organized into folders for different release versions of OTP. OTP Javadoc OTP web service API documentation Contact Info Send questions and comments to the user mailing list . Discuss internal development details on the dev mailing list . File bug reports via the Github issue tracker . Note that the issue tracker is not intended for support questions or discussions. Please post them to one of the mailing lists instead. Financial Support OpenTripPlanner is a member project of Software Freedom Conservancy, a 501(c)(3) organization incorporated in New York, and donations made to it are fully tax-deductible to the extent permitted by law. Donations can be made by credit card, wire transfer or paper check. Please contact accounting@sfconservancy.org for instructions. Be sure to note in the email what country the wire transfer will initiate from and what currency it will be in.","title":"Home"},{"location":"#opentripplanner","text":"This documentation is targeted primarily at the OTP development community and more technical users. For high-level information about the project, please visit www.opentripplanner.org OpenTripPlanner (OTP) is an open source multi-modal trip planner, which runs on Linux, Mac, Windows, or potentially any platform with a Java virtual machine. OTP is released under the LGPL license . The code is under active development with a variety of deployments around the world. If you want to get started right away running your own OTP instance, the best place to start is the Basic Tutorial page.","title":"OpenTripPlanner"},{"location":"#versions-of-this-documentation","text":"OTP Master - Latest release OTP dev-1.x - OTP 1 development branch OTP dev-2.x - OTP 2 development branch","title":"Versions of this documentation"},{"location":"#external-technical-documentation","text":"Some technical documentation is generated automatically from the OTP source code and available from other locations. The Javadoc describes OTP's Java classes and their methods for software developers who call or change this code directly. The Web Service API documents describe the endpoints OTP exposes via its HTTP interface. It is generated automatically by Enunciate from comments in the source code, so may be incomplete or overly verbose in places. These documents are organized into folders for different release versions of OTP. OTP Javadoc OTP web service API documentation","title":"External Technical Documentation"},{"location":"#contact-info","text":"Send questions and comments to the user mailing list . Discuss internal development details on the dev mailing list . File bug reports via the Github issue tracker . Note that the issue tracker is not intended for support questions or discussions. Please post them to one of the mailing lists instead.","title":"Contact Info"},{"location":"#financial-support","text":"OpenTripPlanner is a member project of Software Freedom Conservancy, a 501(c)(3) organization incorporated in New York, and donations made to it are fully tax-deductible to the extent permitted by law. Donations can be made by credit card, wire transfer or paper check. Please contact accounting@sfconservancy.org for instructions. Be sure to note in the email what country the wire transfer will initiate from and what currency it will be in.","title":"Financial Support"},{"location":"Analyst/","text":"Spatial Analysis Concepts and Usage PointSets PointSets are named collections of geographic places that serve as sets of origins or destinations in one-to-many or many-to-many requests. OTP can load PointSets from GeoJSON or CSV files. The following is an example PointSet (two blocks from the 2010 US census) in the GeoJSON format: { \"type\" : \"FeatureCollection\" , \"properties\" : { \"id\" : \"uniqueID\" , \"label\" : \"A short label\" , \"description\" : \"A longer, detailed description of the PointSet as a whole.\" , \"schema\" : { \"pop10\" : { \"style\" : {}, \"label\" : \"population\" }, \"housing10\" : { \"style\" : {}, \"label\" : \"housing units\" } } }, \"features\" : [ { \"properties\" : { \"structured\" : { \"pop10\" : 166 , \"housing10\" : 64 } }, \"geometry\" : { \"coordinates\" : [ -71.13364978767969 , 42.345030084059864 ], \"type\" : \"Point\" }, \"type\" : \"Feature\" , \"id\" : \"tiny_blocks.1\" }, { \"properties\" : { \"structured\" : { \".pop10\" : 76 , \".housing10\" : 34 } }, \"geometry\" : { \"coordinates\" : [ -71.12924764173955 , 42.34592621836178 ], \"type\" : \"Point\" }, \"type\" : \"Feature\" , \"id\" : \"tiny_blocks.2\" } ], } A GeoJSON PointSet is a valid GeoJSON feature collection containing point or polygon features. Each feature has a special property called \"structured\" that contains origin or destination opportunity counts for that location. The features in a PointSet may have other properties of any kind you like (which OTP will ignore), but the structured properties must have integer numeric values. Each feature in this particular PointSet contains a count of people (pop10) and a count of housing units (housing10). Conceptually every feature in the collection has the same set of structured properties, but if one is omitted then its value is assumed to be zero. For example, if one feature has a structured property field called \"population\" with a value of 10, another feature with no such field will be assumed to have a population of zero. The feature collection as a whole can (optionally) have id, label, description, and schema properties.The schema provides additional information about how to display the structured properties that appear in the features, including labels color, and other styling information. This is the same example PointSet in the CSV format: lat,lon,pop10,housing10 42.345030084059864,-71.13364978767969,166,64 42.34592621836178,-71.12924764173955,76,34 Note that while this format is much more compact, it contains no metadata and styling information for the structured properties or the data set as a whole.","title":"Analyst"},{"location":"Analyst/#spatial-analysis-concepts-and-usage","text":"","title":"Spatial Analysis Concepts and Usage"},{"location":"Analyst/#pointsets","text":"PointSets are named collections of geographic places that serve as sets of origins or destinations in one-to-many or many-to-many requests. OTP can load PointSets from GeoJSON or CSV files. The following is an example PointSet (two blocks from the 2010 US census) in the GeoJSON format: { \"type\" : \"FeatureCollection\" , \"properties\" : { \"id\" : \"uniqueID\" , \"label\" : \"A short label\" , \"description\" : \"A longer, detailed description of the PointSet as a whole.\" , \"schema\" : { \"pop10\" : { \"style\" : {}, \"label\" : \"population\" }, \"housing10\" : { \"style\" : {}, \"label\" : \"housing units\" } } }, \"features\" : [ { \"properties\" : { \"structured\" : { \"pop10\" : 166 , \"housing10\" : 64 } }, \"geometry\" : { \"coordinates\" : [ -71.13364978767969 , 42.345030084059864 ], \"type\" : \"Point\" }, \"type\" : \"Feature\" , \"id\" : \"tiny_blocks.1\" }, { \"properties\" : { \"structured\" : { \".pop10\" : 76 , \".housing10\" : 34 } }, \"geometry\" : { \"coordinates\" : [ -71.12924764173955 , 42.34592621836178 ], \"type\" : \"Point\" }, \"type\" : \"Feature\" , \"id\" : \"tiny_blocks.2\" } ], } A GeoJSON PointSet is a valid GeoJSON feature collection containing point or polygon features. Each feature has a special property called \"structured\" that contains origin or destination opportunity counts for that location. The features in a PointSet may have other properties of any kind you like (which OTP will ignore), but the structured properties must have integer numeric values. Each feature in this particular PointSet contains a count of people (pop10) and a count of housing units (housing10). Conceptually every feature in the collection has the same set of structured properties, but if one is omitted then its value is assumed to be zero. For example, if one feature has a structured property field called \"population\" with a value of 10, another feature with no such field will be assumed to have a population of zero. The feature collection as a whole can (optionally) have id, label, description, and schema properties.The schema provides additional information about how to display the structured properties that appear in the features, including labels color, and other styling information. This is the same example PointSet in the CSV format: lat,lon,pop10,housing10 42.345030084059864,-71.13364978767969,166,64 42.34592621836178,-71.12924764173955,76,34 Note that while this format is much more compact, it contains no metadata and styling information for the structured properties or the data set as a whole.","title":"PointSets"},{"location":"Architecture/","text":"Basic OTP Architecture At the core of OpenTripPlanner is a library of Java code that finds efficient paths through multi-modal transportation networks built from OpenStreetMap and GTFS data. Several different services are built upon this library: The OTP Routing API is a RESTful web service that responds to journey planning requests with itineraries in a JSON or XML representation. You can combine this API with OTP's standard Javascript front end to provide users with trip planning functionality in a familiar map interface, or write your own applications that talk directly to the API. The OTP Transit Index API is another RESTful web service that provides information derived from the input GTFS feed(s). Examples include routes serving a particular stop, upcoming vehicles at a particular stop, upcoming stops on a given trip, etc. More complex transit data requests can be formulated using a GraphQL API. The term \"OTP Analyst\" refers to parts of OTP that apply the routing engine to transportation network analysis rather than end-to-end trip planning. OTP Analyst includes: The OTP Analyst Web Services provide network analysis results such as travel time maps and isochrones as standard web Mercator tiles or GIS rasters via a WMS -derived API. These web services are conceptually separate from the routing API, but are provided by the same servlet: once you have a working OTP trip planner you can also use it to produce travel time maps and other visualizations of transit service. See this blog post for discussion and examples. The OTP Analyst Batch Processor is a command-line tool that handles more complex one-off network analysis tasks. It uses the same core routing library and data sources as other OTP services, but allows for very open-ended configuration and the inclusion of population or opportunity data. While configuration and use are currently somewhat opaque for non-developers, the \"Batch Analyst\" is becoming a powerful tool for visualizing how transportation networks affect access to urban opportunities. See this article for an example case study on the effects of hurricane Sandy in New York. The OTP Scripting API allow the execution of routing requests from within scripts (such as Python ). It is composed of a stable internal API, and an embedded Jython interpreter. It can be used in different contexts, such as batch analysis or automated regression testing. More information here .","title":"Architecture"},{"location":"Architecture/#basic-otp-architecture","text":"At the core of OpenTripPlanner is a library of Java code that finds efficient paths through multi-modal transportation networks built from OpenStreetMap and GTFS data. Several different services are built upon this library: The OTP Routing API is a RESTful web service that responds to journey planning requests with itineraries in a JSON or XML representation. You can combine this API with OTP's standard Javascript front end to provide users with trip planning functionality in a familiar map interface, or write your own applications that talk directly to the API. The OTP Transit Index API is another RESTful web service that provides information derived from the input GTFS feed(s). Examples include routes serving a particular stop, upcoming vehicles at a particular stop, upcoming stops on a given trip, etc. More complex transit data requests can be formulated using a GraphQL API. The term \"OTP Analyst\" refers to parts of OTP that apply the routing engine to transportation network analysis rather than end-to-end trip planning. OTP Analyst includes: The OTP Analyst Web Services provide network analysis results such as travel time maps and isochrones as standard web Mercator tiles or GIS rasters via a WMS -derived API. These web services are conceptually separate from the routing API, but are provided by the same servlet: once you have a working OTP trip planner you can also use it to produce travel time maps and other visualizations of transit service. See this blog post for discussion and examples. The OTP Analyst Batch Processor is a command-line tool that handles more complex one-off network analysis tasks. It uses the same core routing library and data sources as other OTP services, but allows for very open-ended configuration and the inclusion of population or opportunity data. While configuration and use are currently somewhat opaque for non-developers, the \"Batch Analyst\" is becoming a powerful tool for visualizing how transportation networks affect access to urban opportunities. See this article for an example case study on the effects of hurricane Sandy in New York. The OTP Scripting API allow the execution of routing requests from within scripts (such as Python ). It is composed of a stable internal API, and an embedded Jython interpreter. It can be used in different contexts, such as batch analysis or automated regression testing. More information here .","title":"Basic OTP Architecture"},{"location":"Basic-Tutorial/","text":"OpenTripPlanner Basic Tutorial This page will get you up and running with your own OTP server. If all goes well it should only take a few minutes! Get OTP OpenTripPlanner is written in Java and distributed as a single runnable JAR file. These JARs are deployed to the Maven Central repository. Go to the OTP directory at Maven Central , navigate to the directory for the highest version number, and download the file whose name ends with .shaded.jar . You may also want to get your own copy of the OTP source code and build a bleeding edge development JAR from scratch , especially if you plan to do some development yourself. Get some data GTFS for Transit Schedules and Stops First you'll need GTFS data to build a transit network. There's an excellent description of the GTFS format here . Transport agencies throughout the world provide GTFS schedules to the public. Transitland has a registry of feeds and TransitFeeds also provides an extensive catalog. The best option is often to simply fetch the data directly from a transit operator or agency. If you know of a feed you want to work with, download it and put it in an empty directory you have created for your OTP instance such as /home/username/otp on Linux, /Users/username/otp on OSX, or C:\\Users\\username\\otp on Windows. The GTFS file's name must end in .zip for OTP to detect it. We often use the convention of ending GTFS file names with .gtfs.zip since technically a GTFS feed is just a ZIP file containing a specific set of files. If you don't have a particular feed in mind, the one for Portland, Oregon's TriMet agency is a good option. It is available at this URL . This is a moderate-sized input of good quality (TriMet initiated OTP development and helped develop the GTFS format). On Linux, this could be done on the command line as follows: $ cd /home/username $ mkdir otp $ cd otp $ wget \"http://developer.trimet.org/schedule/gtfs.zip\" -O trimet.gtfs.zip OSM for Streets You'll also need OpenStreetMap data to build a road network for walking, cycling, and driving. OpenStreetMap is a global collaborative map database that rivals or surpasses the quality of commercial maps in many locations. Several services extract smaller geographic regions from this database. Interline Technologies maintains a collection of extracts updated daily for urban areas around the world . Geofabrik provides extracts for larger areas like countries or states, from which you can prepare your own smaller bounding-box extracts using Osmosis or osmconvert . OSM data can be delivered as XML or in the more compact binary PBF format. OpenTripPlanner can consume both, but we always work with PBF since it's smaller and faster. Download OSM PBF data for the same geographic region as your GTFS feed, and place this PBF file in the same directory you created for the OSM data. If you are using the TriMet GTFS feed, you could download the Geofabrik extract for the US state of Oregon , then further trim that to just the TriMet service area . On Linux or MacOS you could do that as follows: $ cd /home/username $ wget http://download.geofabrik.de/north-america/us/oregon-latest.osm.pbf $ osmconvert oregon-latest.osm.pbf -b=-123.043,45.246,-122.276,45.652 --complete-ways -o=portland.pbf $ mv portland.pbf otp I find this tool useful for determining the geographic coordinates of bounding boxes. The CSV option in that tool produces exactly the format expected by the osmconvert -b switch. The --complete-ways switch is important to handle roads that cross outside your bounding box. If you have extracted a smaller PBF file from a larger region, be sure to put only your extract (not the original larger file) in the directory with your GTFS data. Otherwise OTP will try to load both the original file and the extract in a later step. Start up OTP As a Java program, OTP must be run within a Java virtual machine (JVM), which is provided as part of the Java runtime (JRE) or Java development kit (JDK). Run java -version to check that you have version 1.8 or newer of the JVM installed. If you do not you will need to install a recent OpenJDK or Oracle Java package for your operating system. GTFS and OSM data sets are often very large, and OTP is relatively memory-hungry. You will need at least 1GB of memory when working with the Portland TriMet data set, and several gigabytes for larger inputs. A typical command to start OTP looks like java -Xmx1G -jar otp-0.19.0-shaded.jar <options> . The -Xmx parameter sets the limit on how much memory OTP is allowed to consume. If you have sufficient memory in your computer, set this to a couple of gigabytes (e.g. -Xmx2G ); when OTP doesn't have enough memory \"breathing room\" it can grind to a halt. It's possible to analyze the GTFS, OSM and any other input data and save the resulting representation of the transit network (what we call a 'graph' ) to disk. Then when the OTP server is restarted it can reload this pre-built graph, which is significantly faster than building it from scratch. For simplicity, in this introductory tutorial we'll skip saving the graph file. After the graph is built we'll immediately pass it to an OTP server in memory. The command to do so is: $ java -Xmx2G -jar otp-0.19.0-shaded.jar --build /home/username/otp --inMemory where /home/username/otp should be the directory where you put your input files. The graph build operation should take about one minute to complete, and then you'll see a Grizzly server running message. At this point you have an OpenTripPlanner server running locally and can open http://localhost:8080/ in a web browser. You should be presented with a web client that will interact with your local OpenTripPlanner instance. This map-based user interface is in fact sending HTTP GET requests to the OTP server running on your local machine. It can be informative to watch the HTTP requests and responses being generated using the developer tools in your web browser. OTP's built-in web server will run by default on ports 8080 and 8081. If by any chance some other software is already using those port numbers, you can specify different port numbers with switches like --port 8801 --securePort 8802 . Other simple requests There are a number of different resources available through the HTTP API. Besides trip planning, OTP can also look up information about transit routes and stops from the GTFS you loaded and return this information as JSON. For example: Get a list of all available routers: http://localhost:8080/otp/routers/default/ Get a list all GTFS routes on the default router: http://localhost:8080/otp/routers/default/index/routes Find all stops on TriMet route 52: http://localhost:8080/otp/routers/default/index/routes/TriMet:52/stops Find all routes passing though TriMet stop ID 7003: http://localhost:8080/otp/routers/default/index/stops/TriMet:7003/routes Return all unique sequences of stops on the TriMet Green rail line: http://localhost:8080/otp/routers/default/index/routes/TriMet:4/patterns We refer to this as the Index API. It is also documented in the OTP HTTP API docs .","title":"Basic Tutorial"},{"location":"Basic-Tutorial/#opentripplanner-basic-tutorial","text":"This page will get you up and running with your own OTP server. If all goes well it should only take a few minutes!","title":"OpenTripPlanner Basic Tutorial"},{"location":"Basic-Tutorial/#get-otp","text":"OpenTripPlanner is written in Java and distributed as a single runnable JAR file. These JARs are deployed to the Maven Central repository. Go to the OTP directory at Maven Central , navigate to the directory for the highest version number, and download the file whose name ends with .shaded.jar . You may also want to get your own copy of the OTP source code and build a bleeding edge development JAR from scratch , especially if you plan to do some development yourself.","title":"Get OTP"},{"location":"Basic-Tutorial/#get-some-data","text":"","title":"Get some data"},{"location":"Basic-Tutorial/#gtfs-for-transit-schedules-and-stops","text":"First you'll need GTFS data to build a transit network. There's an excellent description of the GTFS format here . Transport agencies throughout the world provide GTFS schedules to the public. Transitland has a registry of feeds and TransitFeeds also provides an extensive catalog. The best option is often to simply fetch the data directly from a transit operator or agency. If you know of a feed you want to work with, download it and put it in an empty directory you have created for your OTP instance such as /home/username/otp on Linux, /Users/username/otp on OSX, or C:\\Users\\username\\otp on Windows. The GTFS file's name must end in .zip for OTP to detect it. We often use the convention of ending GTFS file names with .gtfs.zip since technically a GTFS feed is just a ZIP file containing a specific set of files. If you don't have a particular feed in mind, the one for Portland, Oregon's TriMet agency is a good option. It is available at this URL . This is a moderate-sized input of good quality (TriMet initiated OTP development and helped develop the GTFS format). On Linux, this could be done on the command line as follows: $ cd /home/username $ mkdir otp $ cd otp $ wget \"http://developer.trimet.org/schedule/gtfs.zip\" -O trimet.gtfs.zip","title":"GTFS for Transit Schedules and Stops"},{"location":"Basic-Tutorial/#osm-for-streets","text":"You'll also need OpenStreetMap data to build a road network for walking, cycling, and driving. OpenStreetMap is a global collaborative map database that rivals or surpasses the quality of commercial maps in many locations. Several services extract smaller geographic regions from this database. Interline Technologies maintains a collection of extracts updated daily for urban areas around the world . Geofabrik provides extracts for larger areas like countries or states, from which you can prepare your own smaller bounding-box extracts using Osmosis or osmconvert . OSM data can be delivered as XML or in the more compact binary PBF format. OpenTripPlanner can consume both, but we always work with PBF since it's smaller and faster. Download OSM PBF data for the same geographic region as your GTFS feed, and place this PBF file in the same directory you created for the OSM data. If you are using the TriMet GTFS feed, you could download the Geofabrik extract for the US state of Oregon , then further trim that to just the TriMet service area . On Linux or MacOS you could do that as follows: $ cd /home/username $ wget http://download.geofabrik.de/north-america/us/oregon-latest.osm.pbf $ osmconvert oregon-latest.osm.pbf -b=-123.043,45.246,-122.276,45.652 --complete-ways -o=portland.pbf $ mv portland.pbf otp I find this tool useful for determining the geographic coordinates of bounding boxes. The CSV option in that tool produces exactly the format expected by the osmconvert -b switch. The --complete-ways switch is important to handle roads that cross outside your bounding box. If you have extracted a smaller PBF file from a larger region, be sure to put only your extract (not the original larger file) in the directory with your GTFS data. Otherwise OTP will try to load both the original file and the extract in a later step.","title":"OSM for Streets"},{"location":"Basic-Tutorial/#start-up-otp","text":"As a Java program, OTP must be run within a Java virtual machine (JVM), which is provided as part of the Java runtime (JRE) or Java development kit (JDK). Run java -version to check that you have version 1.8 or newer of the JVM installed. If you do not you will need to install a recent OpenJDK or Oracle Java package for your operating system. GTFS and OSM data sets are often very large, and OTP is relatively memory-hungry. You will need at least 1GB of memory when working with the Portland TriMet data set, and several gigabytes for larger inputs. A typical command to start OTP looks like java -Xmx1G -jar otp-0.19.0-shaded.jar <options> . The -Xmx parameter sets the limit on how much memory OTP is allowed to consume. If you have sufficient memory in your computer, set this to a couple of gigabytes (e.g. -Xmx2G ); when OTP doesn't have enough memory \"breathing room\" it can grind to a halt. It's possible to analyze the GTFS, OSM and any other input data and save the resulting representation of the transit network (what we call a 'graph' ) to disk. Then when the OTP server is restarted it can reload this pre-built graph, which is significantly faster than building it from scratch. For simplicity, in this introductory tutorial we'll skip saving the graph file. After the graph is built we'll immediately pass it to an OTP server in memory. The command to do so is: $ java -Xmx2G -jar otp-0.19.0-shaded.jar --build /home/username/otp --inMemory where /home/username/otp should be the directory where you put your input files. The graph build operation should take about one minute to complete, and then you'll see a Grizzly server running message. At this point you have an OpenTripPlanner server running locally and can open http://localhost:8080/ in a web browser. You should be presented with a web client that will interact with your local OpenTripPlanner instance. This map-based user interface is in fact sending HTTP GET requests to the OTP server running on your local machine. It can be informative to watch the HTTP requests and responses being generated using the developer tools in your web browser. OTP's built-in web server will run by default on ports 8080 and 8081. If by any chance some other software is already using those port numbers, you can specify different port numbers with switches like --port 8801 --securePort 8802 .","title":"Start up OTP"},{"location":"Basic-Tutorial/#other-simple-requests","text":"There are a number of different resources available through the HTTP API. Besides trip planning, OTP can also look up information about transit routes and stops from the GTFS you loaded and return this information as JSON. For example: Get a list of all available routers: http://localhost:8080/otp/routers/default/ Get a list all GTFS routes on the default router: http://localhost:8080/otp/routers/default/index/routes Find all stops on TriMet route 52: http://localhost:8080/otp/routers/default/index/routes/TriMet:52/stops Find all routes passing though TriMet stop ID 7003: http://localhost:8080/otp/routers/default/index/stops/TriMet:7003/routes Return all unique sequences of stops on the TriMet Green rail line: http://localhost:8080/otp/routers/default/index/routes/TriMet:4/patterns We refer to this as the Index API. It is also documented in the OTP HTTP API docs .","title":"Other simple requests"},{"location":"Bibliography/","text":"Routing Bibliography This is a list of articles, dissertations, and books that have inspired and informed both the existing OTP routing engine and some ongoing experiments. Currently, OTP uses a single time-dependent (as opposed to time-expanded) graph that contains both street and transit networks. Walk-only and bicycle-only trips are generally planned using the A-star algorithm with a Euclidean heuristic. Walk+Transit or Bike+Transit trips are planned using A-star with the Tung-Chew heuristic (i.e. a graph grown backward from the destination providing a lower bound on aggregate weight) for queue ordering. Currently we are performing single-variable generalized cost optimization, which is not ideal. We should be performing Pareto optimization on at least two variables (generalized cost and time) but will need to do some optimizations and check performance. Path Search Speedup Techniques Bast, Hannah. Car or public transport -- two worlds. (2009) Explains how car routing is different from schedule-based public transport routing. http://www.mpi-inf.mpg.de/~bast/papers/car_or_public_transport.pdf Delling, Daniel. Engineering and augmenting route planning algorithms. (2009, dissertation) Overview, including time-dependent and Pareto shortest paths. http://i11www.ira.uka.de/extra/publications/d-earpa-09.pdf Delling, Sanders, Schultes, and Wagner. Engineering Route-Planning Algorithms. (2009) Overview. http://i11www.ira.uka.de/extra/publications/dssw-erpa-09.pdf Delling and Wagner. Time-Dependent Route Planning. (2009) Overview. http://i11www.iti.uni-karlsruhe.de/extra/publications/dw-tdrp-09.pdf Delling and Wagner. Landmark-Based Routing in Dynamic Graphs. (2008) http://i11www.ira.uka.de/extra/publications/dw-lbrdg-07.pdf Bauer, Delling, Sanders, Schultes, and Wagner. Combining Hierarchical and Goal-Directed Speed-Up Techniques for Dijkstra\u2019s Algorithm. (2008) http://algo2.iti.kit.edu/download/bdsssw-chgds-10.pdf Bauer and Delling. SHARC: Fast and Robust Unidirectional Routing. (2009) SH ortcuts + ARC flags. Can be combined with ALT. http://www.siam.org/proceedings/alenex/2008/alx08_02bauerr.pdf Delling, Daniel. Time-Dependent SHARC-Routing. (2008) http://i11www.iti.uni-karlsruhe.de/extra/publications/d-tdsr-09.pdf Goldberg, Kaplan, and Werneck. Reach for A\u2217: Efficient Point-to-Point Shortest Path Algorithms. (2005) http://avglab.com/andrew/pub/msr-tr-2005-132.pdf Multi-objective Pareto Shortest Paths Das and Dennis. Drawbacks of minimizing weighted sums of objectives for Pareto set generation in multicriteria optimization problems. (1997) M\u00fcller-Hannemann and Schnee. Finding All Attractive Train Connections by Multi-criteria Pareto Search. (2007) Deutsche Bahn information system. Does not account for on-street travel. Mandow & P\u00e9rez de la Cruz. A New Approach to Multiobjective A Search. (2005) NAMOA http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.97.8780&rep=rep1&type=pdf Mandow & P\u00e9rez de la Cruz. Multiobjective A search with consistent heuristics. (2008) NAMOA Machuca, Mandow and P\u00e9rez de la Cruz. Evaluation of Heuristic Functions for Bicriterion Shortest Path Problems. (2009) Evaluates heuristics from Tung & Chew (1992) versus lexicographical ordering of priority queue. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.160.4715&rep=rep1&type=pdf Perny and Spanjaard. Near Admissible Algorithms for Multiobjective Search. (2009) Discusses relaxed Pareto dominance (Epsilon-dominance) and its use in Multi-objective A*. This a scheme for approximating the entire pareto-optimal solution set that allows time and space complexity polynomial in the number of nodes. http://www-desir.lip6.fr/publications/pub_1052_1_ECAI08.pdf Tung and Chew. A multicriteria Pareto-optimal path algorithm. (1992) Delling and Wagner. Pareto Paths with SHARC. (2009) http://i11www.iti.uni-karlsruhe.de/extra/publications/dw-pps-09.pdf Resource-constrained Routing Dumitrescu & Boland. Improved Preprocessing, Labeling and Scaling Algorithms for the Weight-Constrained Shortest Path Problem. (2003) Comparison of scaling and label-setting methods. Ziegelmann, Mark. Constrained Shortest Paths and Related Problems. (2001, dissertation) http://scidok.sulb.uni-saarland.de/volltexte/2004/251/pdf/MarkZiegelmann_ProfDrKurtMehlhorn.pdf Contraction and Transfer Patterns Geisberger, Robert. Contraction Hierarchies: Faster and Simpler Hierarchical Routing in Road Networks. (2008, dissertation) http://algo2.iti.kit.edu/documents/routeplanning/geisberger_dipl.pdf Geisberger, Robert. Contraction of Timetable Networks with Realistic Tranfers (2010) Introduces the \"Station Model Graph\". http://algo2.iti.kit.edu/download/time_table_ch.pdf Bast, Carlsson, Eigenwillig, Geisberger Harrelson, Raychev, and Viger. Fast Routing in Very Large Public Transportation Networks Using Transfer Patterns. (2010) http://ad.informatik.uni-freiburg.de/files/transferpatterns.pdf/at_download/file Timetable-based routing Schulz, Frank. Timetable Information and Shortest Paths. (2005, dissertation) Excellent reference. http://d-nb.info/1001586921/34 ALT and Metric Embeddings Goldberg and Werneck. Computing Point-to-Point Shortest Paths from External Memory. (2005) Introduced the ALT algorithm. http://www.cs.princeton.edu/courses/archive/spring06/cos423/Handouts/GW05.pdf Linial, London, and Rabinovich. The Geometry of Graphs and Some of its Algorithmic Applications. (1995) http://pdf.aminer.org/000/798/423/the_geometry_of_graphs_and_some_of_its_algorithmic_applications.pdf Hjaltason and Samet. Contractive Embedding Methods for Similarity Searching in Metric Spaces. (2000) http://www.cs.umd.edu/~hjs/pubs/metricpruning.pdf Potamias, Bonchi, Castillo, and Gionis. Fast Shortest Path Distance Estimation in Large Networks. (2009) Briefly discusses the connection between landmark routing and more general research on metric embeddings. http://dcommon.bu.edu/xmlui/bitstream/handle/2144/1727/2009-004-shortest-distance-estimation.pdf Calibration and Implementation Details Wardman, Mark. Public Transport Values of Time. (2004) http://eprints.whiterose.ac.uk/2062/1/ITS37_WP564_uploadable.pdf A.M. El-Geneidy, K.J. Krizek, M.J. Iacono. Predicting bicycle travel speeds along different facilities using GPS data: a proof of concept model. (2007) Proceedings of the 86th Annual Meeting of the Transportation Research Board, Compendium of Papers, TRB, Washington, D.C., USA (CD-ROM) Chen, Chowdhury, Roche, Ramachandran, Tong. Priority Queues and Dijkstra\u2019s Algorithm. Summary: Despite better theoretical complexity for Fibonacci heaps, it is often as good or better to use a binary heap as a priority queue when doing path searches. http://www.cs.utexas.edu/users/shaikat/papers/TR-07-54.pdf Post-Dijkstra Public Transit Routing Delling, Pajor, Werneck. Round-Based Public Transit Routing (2012) This is a tabular approach to routing in public transit networks that does not use an (explicit) graph. It is simpler and can outperform classic graph algorithms. http://research.microsoft.com/pubs/156567/raptor_alenex.pdf Dibbelt, Pajor, Strasser, Wagner. Intriguingly Simple and Fast Transit Routing (2013). Introduces the Connection Scan Algorithm (CSA). http://www.ecompass-project.eu/sites/default/files/ECOMPASS-TR-021.pdf Delling, Katz, and Pajor. Parallel computation of best connections in public transportation networks (2012). \"In this work, we present a novel algorithm for the one-to-all profile-search problem in public transportation networks. It answers the question for all fastest connections between a given station S and any other station at any time of the day in a single query... two interesting questions arise for time-dependent route planning: compute the best connection for a given departure time and the computation of all best connections during a given time interval (e. g., a whole day). The former is called a time-query, while the latter is called a pro\ufb01le-query.\" http://www.ecompass-project.eu/sites/default/files/ECOMPASS-TR-021.pdf Analysis Bibliography This is a list of articles about non-passenger-facing applications of multi-modal routing engines (including OTP) in urban planning, public policy, economics, geography etc. Busby, Jeffrey R. \u201cAccessibility-Based Transit Planning\u201d. MA thesis. Massachusetts Institute of Technology, 2004. Web. [http://dspace.mit.edu/handle/1721.1/32414] Lei, T. L. and R. L. Church. \u201cMapping transit-based access: integrating GIS, routes and schedules.\u201d International Journal of Geographical Information Science 24.2 (2010): 283\u2013304. Web. [http://www.tandfonline.com/doi/pdf/10.1080/13658810902835404]. McGurrin, Greczner. Performance Metrics: Calculating Accessibility Using Open Source Software and Open Data. (2010). Web. [http://amonline.trb.org/12jj6e/12jj6e/1] An approach for calculating accessibility via both transit and automobiles is presented. OTP is used for the transit portion. Tomer, Kneebone, Puentes, and Berube. Missed Opportunity: Transit and Jobs in Metropolitan America. (2011) Large-scale comparative public transit accessibility study. [http://www.brookings.edu/reports/2011/0512_jobs_and_transit.aspx] Huang, Ruihong. \"Bridging GTFS and GIS for Computing Transit Level of Service,\" Association of American Geographers Annual Meeting. (2011) Presents data models and techniques to bridge GTFS data and GIS data and facilitate computation of various transit system level of service (TLOS) indicators for U.S. metropolitan areas. [http://meridian.aag.org/callforpapers/program/AbstractDetail.cfm?AbstractID=39742] Trozzi, Hosseinloo, Gentile2, and Bell. Dynamic Hyperpaths: The Stop Model. (2009) paper 1 paper 2 Effective frequencies of multiple frequency-based routes operating over common trunks. The passenger's position should be modeled as a superposition of positions along the various lines. Some work must be done here to present reasonable trips.","title":"Bibliography"},{"location":"Bibliography/#routing-bibliography","text":"This is a list of articles, dissertations, and books that have inspired and informed both the existing OTP routing engine and some ongoing experiments. Currently, OTP uses a single time-dependent (as opposed to time-expanded) graph that contains both street and transit networks. Walk-only and bicycle-only trips are generally planned using the A-star algorithm with a Euclidean heuristic. Walk+Transit or Bike+Transit trips are planned using A-star with the Tung-Chew heuristic (i.e. a graph grown backward from the destination providing a lower bound on aggregate weight) for queue ordering. Currently we are performing single-variable generalized cost optimization, which is not ideal. We should be performing Pareto optimization on at least two variables (generalized cost and time) but will need to do some optimizations and check performance.","title":"Routing Bibliography"},{"location":"Bibliography/#path-search-speedup-techniques","text":"Bast, Hannah. Car or public transport -- two worlds. (2009) Explains how car routing is different from schedule-based public transport routing. http://www.mpi-inf.mpg.de/~bast/papers/car_or_public_transport.pdf Delling, Daniel. Engineering and augmenting route planning algorithms. (2009, dissertation) Overview, including time-dependent and Pareto shortest paths. http://i11www.ira.uka.de/extra/publications/d-earpa-09.pdf Delling, Sanders, Schultes, and Wagner. Engineering Route-Planning Algorithms. (2009) Overview. http://i11www.ira.uka.de/extra/publications/dssw-erpa-09.pdf Delling and Wagner. Time-Dependent Route Planning. (2009) Overview. http://i11www.iti.uni-karlsruhe.de/extra/publications/dw-tdrp-09.pdf Delling and Wagner. Landmark-Based Routing in Dynamic Graphs. (2008) http://i11www.ira.uka.de/extra/publications/dw-lbrdg-07.pdf Bauer, Delling, Sanders, Schultes, and Wagner. Combining Hierarchical and Goal-Directed Speed-Up Techniques for Dijkstra\u2019s Algorithm. (2008) http://algo2.iti.kit.edu/download/bdsssw-chgds-10.pdf Bauer and Delling. SHARC: Fast and Robust Unidirectional Routing. (2009) SH ortcuts + ARC flags. Can be combined with ALT. http://www.siam.org/proceedings/alenex/2008/alx08_02bauerr.pdf Delling, Daniel. Time-Dependent SHARC-Routing. (2008) http://i11www.iti.uni-karlsruhe.de/extra/publications/d-tdsr-09.pdf Goldberg, Kaplan, and Werneck. Reach for A\u2217: Efficient Point-to-Point Shortest Path Algorithms. (2005) http://avglab.com/andrew/pub/msr-tr-2005-132.pdf","title":"Path Search Speedup Techniques"},{"location":"Bibliography/#multi-objective-pareto-shortest-paths","text":"Das and Dennis. Drawbacks of minimizing weighted sums of objectives for Pareto set generation in multicriteria optimization problems. (1997) M\u00fcller-Hannemann and Schnee. Finding All Attractive Train Connections by Multi-criteria Pareto Search. (2007) Deutsche Bahn information system. Does not account for on-street travel. Mandow & P\u00e9rez de la Cruz. A New Approach to Multiobjective A Search. (2005) NAMOA http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.97.8780&rep=rep1&type=pdf Mandow & P\u00e9rez de la Cruz. Multiobjective A search with consistent heuristics. (2008) NAMOA Machuca, Mandow and P\u00e9rez de la Cruz. Evaluation of Heuristic Functions for Bicriterion Shortest Path Problems. (2009) Evaluates heuristics from Tung & Chew (1992) versus lexicographical ordering of priority queue. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.160.4715&rep=rep1&type=pdf Perny and Spanjaard. Near Admissible Algorithms for Multiobjective Search. (2009) Discusses relaxed Pareto dominance (Epsilon-dominance) and its use in Multi-objective A*. This a scheme for approximating the entire pareto-optimal solution set that allows time and space complexity polynomial in the number of nodes. http://www-desir.lip6.fr/publications/pub_1052_1_ECAI08.pdf Tung and Chew. A multicriteria Pareto-optimal path algorithm. (1992) Delling and Wagner. Pareto Paths with SHARC. (2009) http://i11www.iti.uni-karlsruhe.de/extra/publications/dw-pps-09.pdf","title":"Multi-objective Pareto Shortest Paths"},{"location":"Bibliography/#resource-constrained-routing","text":"Dumitrescu & Boland. Improved Preprocessing, Labeling and Scaling Algorithms for the Weight-Constrained Shortest Path Problem. (2003) Comparison of scaling and label-setting methods. Ziegelmann, Mark. Constrained Shortest Paths and Related Problems. (2001, dissertation) http://scidok.sulb.uni-saarland.de/volltexte/2004/251/pdf/MarkZiegelmann_ProfDrKurtMehlhorn.pdf","title":"Resource-constrained Routing"},{"location":"Bibliography/#contraction-and-transfer-patterns","text":"Geisberger, Robert. Contraction Hierarchies: Faster and Simpler Hierarchical Routing in Road Networks. (2008, dissertation) http://algo2.iti.kit.edu/documents/routeplanning/geisberger_dipl.pdf Geisberger, Robert. Contraction of Timetable Networks with Realistic Tranfers (2010) Introduces the \"Station Model Graph\". http://algo2.iti.kit.edu/download/time_table_ch.pdf Bast, Carlsson, Eigenwillig, Geisberger Harrelson, Raychev, and Viger. Fast Routing in Very Large Public Transportation Networks Using Transfer Patterns. (2010) http://ad.informatik.uni-freiburg.de/files/transferpatterns.pdf/at_download/file","title":"Contraction and Transfer Patterns"},{"location":"Bibliography/#timetable-based-routing","text":"Schulz, Frank. Timetable Information and Shortest Paths. (2005, dissertation) Excellent reference. http://d-nb.info/1001586921/34","title":"Timetable-based routing"},{"location":"Bibliography/#alt-and-metric-embeddings","text":"Goldberg and Werneck. Computing Point-to-Point Shortest Paths from External Memory. (2005) Introduced the ALT algorithm. http://www.cs.princeton.edu/courses/archive/spring06/cos423/Handouts/GW05.pdf Linial, London, and Rabinovich. The Geometry of Graphs and Some of its Algorithmic Applications. (1995) http://pdf.aminer.org/000/798/423/the_geometry_of_graphs_and_some_of_its_algorithmic_applications.pdf Hjaltason and Samet. Contractive Embedding Methods for Similarity Searching in Metric Spaces. (2000) http://www.cs.umd.edu/~hjs/pubs/metricpruning.pdf Potamias, Bonchi, Castillo, and Gionis. Fast Shortest Path Distance Estimation in Large Networks. (2009) Briefly discusses the connection between landmark routing and more general research on metric embeddings. http://dcommon.bu.edu/xmlui/bitstream/handle/2144/1727/2009-004-shortest-distance-estimation.pdf","title":"ALT and Metric Embeddings"},{"location":"Bibliography/#calibration-and-implementation-details","text":"Wardman, Mark. Public Transport Values of Time. (2004) http://eprints.whiterose.ac.uk/2062/1/ITS37_WP564_uploadable.pdf A.M. El-Geneidy, K.J. Krizek, M.J. Iacono. Predicting bicycle travel speeds along different facilities using GPS data: a proof of concept model. (2007) Proceedings of the 86th Annual Meeting of the Transportation Research Board, Compendium of Papers, TRB, Washington, D.C., USA (CD-ROM) Chen, Chowdhury, Roche, Ramachandran, Tong. Priority Queues and Dijkstra\u2019s Algorithm. Summary: Despite better theoretical complexity for Fibonacci heaps, it is often as good or better to use a binary heap as a priority queue when doing path searches. http://www.cs.utexas.edu/users/shaikat/papers/TR-07-54.pdf","title":"Calibration and Implementation Details"},{"location":"Bibliography/#post-dijkstra-public-transit-routing","text":"Delling, Pajor, Werneck. Round-Based Public Transit Routing (2012) This is a tabular approach to routing in public transit networks that does not use an (explicit) graph. It is simpler and can outperform classic graph algorithms. http://research.microsoft.com/pubs/156567/raptor_alenex.pdf Dibbelt, Pajor, Strasser, Wagner. Intriguingly Simple and Fast Transit Routing (2013). Introduces the Connection Scan Algorithm (CSA). http://www.ecompass-project.eu/sites/default/files/ECOMPASS-TR-021.pdf Delling, Katz, and Pajor. Parallel computation of best connections in public transportation networks (2012). \"In this work, we present a novel algorithm for the one-to-all profile-search problem in public transportation networks. It answers the question for all fastest connections between a given station S and any other station at any time of the day in a single query... two interesting questions arise for time-dependent route planning: compute the best connection for a given departure time and the computation of all best connections during a given time interval (e. g., a whole day). The former is called a time-query, while the latter is called a pro\ufb01le-query.\" http://www.ecompass-project.eu/sites/default/files/ECOMPASS-TR-021.pdf","title":"Post-Dijkstra Public Transit Routing"},{"location":"Bibliography/#analysis-bibliography","text":"This is a list of articles about non-passenger-facing applications of multi-modal routing engines (including OTP) in urban planning, public policy, economics, geography etc. Busby, Jeffrey R. \u201cAccessibility-Based Transit Planning\u201d. MA thesis. Massachusetts Institute of Technology, 2004. Web. [http://dspace.mit.edu/handle/1721.1/32414] Lei, T. L. and R. L. Church. \u201cMapping transit-based access: integrating GIS, routes and schedules.\u201d International Journal of Geographical Information Science 24.2 (2010): 283\u2013304. Web. [http://www.tandfonline.com/doi/pdf/10.1080/13658810902835404]. McGurrin, Greczner. Performance Metrics: Calculating Accessibility Using Open Source Software and Open Data. (2010). Web. [http://amonline.trb.org/12jj6e/12jj6e/1] An approach for calculating accessibility via both transit and automobiles is presented. OTP is used for the transit portion. Tomer, Kneebone, Puentes, and Berube. Missed Opportunity: Transit and Jobs in Metropolitan America. (2011) Large-scale comparative public transit accessibility study. [http://www.brookings.edu/reports/2011/0512_jobs_and_transit.aspx] Huang, Ruihong. \"Bridging GTFS and GIS for Computing Transit Level of Service,\" Association of American Geographers Annual Meeting. (2011) Presents data models and techniques to bridge GTFS data and GIS data and facilitate computation of various transit system level of service (TLOS) indicators for U.S. metropolitan areas. [http://meridian.aag.org/callforpapers/program/AbstractDetail.cfm?AbstractID=39742] Trozzi, Hosseinloo, Gentile2, and Bell. Dynamic Hyperpaths: The Stop Model. (2009) paper 1 paper 2 Effective frequencies of multiple frequency-based routes operating over common trunks. The passenger's position should be modeled as a superposition of positions along the various lines. Some work must be done here to present reasonable trips.","title":"Analysis Bibliography"},{"location":"Changelog/","text":"Changelog 1.5.0 (2020-11-27) Add application/x-protobuf to accepted protobuf content-types (#2839) Add Way Property Set for the UK (#2818) Fixes surefire test failure during build (#2816) Improve documentation for mode routing parameter (#2809) Disable linking from already linked stops (#2372) Optimize elevation calculations 1.4 (2019-07-30) Remove Open Traffic prototype code (#2698) Improved configuration documentation Update onebusaway-gtfs to latest version from OBA project (#2636) Remove the coupling to OneBusAway GTFS within OTP's internal model by creating new classes replacing the external classes (#2494) Allow OTP to search more service days for transit service (#2592) Allow itineraries in response to be sorted by duration (#2593) Add support for GTFS-flex services: flag stops, deviated-route service, and call-and-ride (#2603) Fix reverse optimization bug (#2653, #2411) increase GTFS-realtime feeds size limit from 64MB to 2G (#2738) Fix XML response serialization (#2685) Refactor InterleavedBidirectionalHeuristic (#2671) Add \"Accept\" headers to GTFS-RT HTTP requests (#2796) Fix minor test failure against BANO geocoder (#2798) Fix frequency bounds checking (#2540) Fix JTS coordinate order for Polygons/Polylines (#2784) Add JAXB API to allow compilation under Java 11 Remove dependency on Conveyal jackson2-geojson Changed calculation of slope costs (#2579) Replace Java built in serialization with faster Kryo (#2681) Support OSM highway=razed tag (#2660) Memory leak fix (#2655) Add bicimad bike rental updater (#2503) Add Smoove citybikes updater (#2515) Switched to single license file, removing all OTP and OBA file license headers 1.3 (2018-08-03) Fix stop linking to only one edge of platform (#2472) Log and allow changing number of HTTP handler threads Update Dutch base fare from 89 to 90 cents (#2608) Add Dutch fare service (#2571) Revise unit tests to use less memory Run all graph updater setup methods sequentially (#2545) Allow vehicle rental systems with cars (stopgap parameter on bike rental) Bump R5 version to get newer gtfs-lib and FST serialization Move stopClusterMode parameter from routing config to build config (#2558) Update encrypted Maven artifact signing key (it expired) Clean up logging Remove/update deprecated HTTPClient, add missing SSL ciphers (#2451) Make maxTransfer options configurable through scripting API (#2507) Fix scripts when entity IDs contain colons (#2474) Add HTML report for stops more than 20m from linked road (#2460) Update fares in NycFareServiceImpl (#2466) Compact legs NPE fix (#2449) (#2490) Docs: elevation data configuration, USGS DEM files Docs: Update list of deployments Docs: API, list of deployments, usage stats and tutorials Docs: Update leadership committee listing following Boston Summit Docs: Update OTP logo (Thanks Kate Chanba!) 1.2 (2017-09-18) Add support for consuming GBFS bike-rental availability feeds. #2458 Add GBFS configuration example Add flag for including requested start/end time in maxHours in planner API. #2457 Add maxTransferDistance graph builder parameter Add option for filtering non-pickup stops in TransitIndex stop times functions. #2377 Support foot/bicycle=discouraged OSM tag. #2415 Improve linking of transit platforms to connecting access ways. #2422 / #2428 Fix bug when building graph with parent station transfers. #2404 / #2410 Fix bugs in park and ride search. #2424 Support different stop ID formats in field trip module Update URL in BANO geocoding module. #2438 / #2439 Add more debug information related to trips matching using GTFS-RT feed. #2432 Update default PATH_NOT_FOUND message to new wording developed w/ TriMet. #2355 Update Travis build configuration to not attempt GPG operations. #2441 Fix javadoc URL in scripting documentation. #2437 Automatically link to GitHub issues in Changelog. #2426 Expose FeedInfo objects in the Index API #2456 Changes to Puget Sound region fare calculation #2484 Fix coordinatates when clustering by parent station #2447 Allow setting OSM Way Properties from build-config.json #2389 Optionally compact (\"reverse-optimize\") results with complete reverse search #2449 Add updater for urbaninfrastructure city bikes #2448 Miscellaneous documentation updates 1.1 (2017-03-16) Deploy to Sonatype OSSRH and Maven Central Documentation updates including repo links New router-config stopClusterMode: clustering by parent station or geography #2364 Spanish and Portuguese UI Translations In TimeSurface API, serialize travel times to every point when detail=true Make OSM highway=corridor pedestrian routable Fix GraphIndex.stopTimesForStop to search on the request day rather than now Update GraphQL to latest version and improve support for complex arguments #2367 Add support for operationName to the graphql endpoint Fix findClosestStopsByWalking, properly set RoutingContext Fixed major routing problem where dead-end SimpleTransfers blocked walking paths #2414 Created Github issue template Avoid negative elevation figures: Compute ellipsoid-geoid offset and optionally apply to elevation calculations #2301 Fix VCub bike share updater using new API variable names. Fix spurious different-day warning #2399 Shutdown hook to gracefully shut down Grizzly #2384 Added headsign attribute for stoptimes in GraphQL #2224 Allow Cars on highway=*;bicycle=designated #2374 Expose PruneFloatingIslands parameters in build-config.json Lazy initialization of stop clusters where needed Include Agency/Route branding in responses Include turn-by-turn walking directions for transfer legs #1707 Output error when edge lengths are negative, and set them to 1mm Add disableAlertFiltering API flag #2351 Do not show arrival times at terminal stops in stop time viewer #2357 Index API now returns stop information URL, enabling hyperlinks in trip viewer #2352 Remove all unused model classes for index API #1301 Apply an interlining fix from 0.10 branch Allow quoted search phrases in the Lucene search #2279 Re-implement maxHours filter #2332 Properly set wheelchairAccessible on area edges Fixed file URL in test #2339 Add details field to fares, listing which legs each fare applies to #1699 1.0 (2016-09-09) Fix problem with missing embedded router-configs. Check whether trips have been banned when applying in-seat transfers (interlining). Load embedded config for existing graphs on disk. Apply max walk distance to transfers, not just initial and final walk. Remove Conveyal tiles from client (which was getting expensive), add free Carto/MapZen tiles. Fixed headsigns: in itineraries, headsign for a leg used to always be the last stop. Updated default map tile sets in the client because Mapquest is no longer gratis. Fix problem with empty list ??? #1873 Rewrite of intermediate places handling in GraphPathFinder. Original request is cloned for each intermediate path. Routes in GraphQL API Change \"type\" to \"mode\" and add \"type\" as route type to Route for GraphQL Add effective end date to alerts (from HSL). Rutebanken Citybike bike share. Correct TPEG transport modes TPEG 401 and 402 to be \"subway\". Ignore exceptions caused by errors in OSM linear rings. Updated to version 2.18 of Jersey to fix hanging threads in Grizzly. Removed confusing \"Busish\" and \"Trainish\" pseudo-modes. FareService for Seattle: allow specifying fares in GTFS instead of hard-coding them in Java. Senior/youth fare prices are given in an extra column in fare attributes. Per-trip fares are taken into consideration when calculating fares in this region. Update new linker to link to transitStops if no streets are found. Show the name supplied in the request for the origin/destination points in the response. Throw a trivialPath exception if start/end point are on the same edge. Switch to only use the new SimpleStreetLinker, even for search start and end points. Completely removed old linker classes. Changes for proper handling of wheelchairs and bicycles at start and end points. Properly handle null timetableSnapshots when there is no real-time data. 0.20 (2016-06-10) Re-enabled Enunciate, which works properly with OTP now. This means we have auto-generated API docs. Make headsign and block ID visible in the Stop Viewer. NYC fare service: filter out non-NYC agencies. Optionally log all requests to a file. Make max distance for in-seat transfers (interlining) configurable. Previously it was hardcoded at 200m. Polish translation for web client. Introduced bikeShareId in trip plans (separate from stopIds). Support for ShareBike bike rental system in Oslo, Drammen, Trondheim, Milan, Barcelona and Mexico City among others. Changed default waitAtBeginningFactor and timeouts. Show alert in client when itinerary departure date differs from search date. Exposed realtimeState in GraphQL responses. Fixed a routerConfig NullPointerException. Support for San Francisco bike share from leoromanovsky. GraphQL API for most transit data from hannesj. Disallow shortcuts through multiple StationStopEdges. Add support for airplanes (from HSL) Major simplification and correction of the longDistance heuristic, removed obsolete runState.options.heuristicWeight. Return default OSM level for ways that are not found. Profile routing: use earliest arrival objective function on-street, properly handle TrivialPathExceptions. Fixed ID matching when applying AlertPatches. Fixed banning of agencies in multi agency feeds. More coherent handling of feed IDs as scope for GTFS IDs. Added transit service start and end timestamps to BuildInfo. Handle embeded router configuration for POSTed graphs and zips for building. Simplified router-config handling. Properly lazy-initialize profile routing stopClusters. Added stop clusters to the Index API. Completely removed the ill-advised path parser system, which was too clever for its own good. Sort itineraries by total travel time rather than in-transit time. Rental bikes: allow loading generic KML. Removed the experimental TransportNetwork classes, which shared no code with the rest of OTP and were duplicated in the R5 project. There are still some elements that can be cleaned out when only R5 is used by Conveyal's analysis system. The broker code in OTP is now able to start up R5 workers for Analyst. Use the Conveyal fork of the OBA GTFS loader, so that we can add our own extensions to GTFS. Updated docs to offer Conveyal Maven repo as a place to get prebuilt OTP. 0.19.0 (2016-05-25) TODO 0.18.0 (2015-05-29) Ability to load elevation from projected GeoTIFF Clarified axis order for unprojected GeoTIFFs Stop viewer and car distance fixed in client Server-side localization improvements Proper names for intersections JSON config for loading bikeshare and park and ride lots from OSM More ways to fetch isochrones Fixed frequency-based routing in repeated RAPTOR Calculate graph envelope at build time not runtime Fixed slow excessive HashGrid search Readthedocs documentation updates 0.17.0 (2015-05-14) Allow fetching arrivals/departures over a particular time window Completely new spatial analysis implementation: repeated RAPTOR search at every minute in a departure time window More reproducible spatial analysis results across similar graphs, thanks to more consistent splitting of streets etc. Sigmoidal accessibility metric rolloff (rather than hard-edged cutoff) Correction of equirectangular projection used in spatial analysis Improved, simplified, deterministic linking of stops into the street network 0.16.0 (2015-05-07) Several improvements to OSM tag based traversal permissions Scripting documentation Accept TIFF files whose names end in .tiff not .tif Store distances (not times) in Analyst Samples to allow variable walk speed Fixed bug in graph auto-scanning Fixed client-side bug in first and last itinerary buttons OTP startup scripts no longer use wildcards Transit, bike rental, and parking linking done in one module Elevation tiles for the US can be fetched from Amazon S3 Bumped language level to Java 8 (lambda functions, method references, collection streams) 0.15.0 (2015-04-14) Fare module for Seattle JSON fare module and OSM street naming configuration Significant improvements to speed and result quality of Profile Routing Support for added and modified GTFS-RT trips (thanks Jaap Koelewijn of DAT Mobility and Plannerstack) Detailed edge lists in profile routing responses (for Transitive.js) Support for multiple access modes including bike rental in profile routing Fixes to graph reloading via web API Improved comments in code and documentation of PointSets Pulled MapDB GTFS loader out into a separate repo Working artifact version was 0.15.0-SNAPSHOT instead of 1.0.0-SNAPSHOT (anticipating frequent point releases) 0.14.0 (2015-03-28) JSON configuration of graph building and routers Began moving documentation (including this changelog) into the OTP repo and rewriting it page by page. It is built statically from Markdown using mkdocs and published on readthedocs. Street edge lists and bike rental station IDs in profile routing results (allows better rendering) Improved correctness of profile routing Qualified modes including rented bikes work in profile routing Simplification of qualified mode sets Elevation models are loaded from TIFFs in graph directory Tiles for differences between TimeSurfaces Restructured relationship between Routers and Graphs Various changes enabling use of Analyst features in a cluster computing environment. Removed several single-implementation interfaces, factories, services and other superfluous abstractions Various client fixes related to the transit index API Revised nearby stops logic and transfer generation to eliminate useless transfer edges New Index API endpoints for geometries, transfers etc. Isochrone generation fixes Default mode of operation is now \u201clong distance mode\u201d Process for finding alternative routes is now based on banning trips and retrying, while reusing the heuristic Optimization objective functions are swappable, and have been simplified and corrected All client Javascript librariess are now pulled from a CDN Dutch BAG and French BANO geocoders Bus to street matching improvements Complete MapDB based GTFS and OSM loader libraries (will become separate projects, not yet connected to OTP graph builder) API documentation generation working again Disable some time consuming graph building steps by default Finnish and Swedish translations Subway-specific JSON configuration options (street to platform time) Realtime fetch / streaming configurable via JSON Stairs reluctance is much higher when carrying a bike Graph visualizer routing progress animates when a search is triggered via the web API Assume WGS84 (spherical distance calculations) everywhere Removed custom motor vehicle (which was unmaintained and not documented) Ability to poll for bike rental locations only once at startup Stoptimes are fetched for a specific service day in index API Bicycle triangle support in profile routing Proper handling of multiple access modes with different speeds in profile routing Command line option to output OTP's version 0.13.0 (2014-12-05) Detect apparent errors in GTFS interlining Long distance mode: use a pure weight-based state comparison, and use trip-banning retrying logic to get multiple paths. This compromises correctness somewhat but brings search times back within reason for large regional graphs. Also, we create significantly less SimpleTransfers. Progress on GTFS reading and writing library (not yet used by OTP). Bug fixes for tiny street edges, time zones. Deployment of artifacts to maven.conveyal.com via S3. Handle park and ride lots that have roads running through them, but don't share nodes with those roads. 0.12.1 (2014-11-17) Fixed threading problem caused by graph visualization instrumentation #1611 Fixed 'unconnected areas' infinite loop #1605 0.12.0 (2014-11-11) Graph building from zipball of data sent over the wire OTP-specific GTFS loader library with error checking and recovery Bike and car park and ride improvements Stable hash codes for stop patterns and trips Bicycle safety and wheelchair access tile generators Newer versions of Grizzly, Jackson, and Enunciate (documentation generation now works) Redesigned HashGrid spatial index Significant reduction in graph size in memory and on disk Improved internationalization Ability to pause and step search in graph visualizer Additional graph visualizer modes for spotting overbranching Movement toward 1.0 web services API Kiss and Ride Complete removal of Spring Complete removal of Lombok CORS replaces JSONP Pointset classes for dealing with one-to-many calculations and accessibility calculations Experimental \"Profile routing\" which enumerates reasonable route combinations over a time range rather than exact itineraries Single-module Maven build (complete elimination of submodules) Alternate Gradle build script full internationalization of the map-based web client basic Lucene-based built-in geocoder 0.11.0 (2014-03-24) Built-in HTTP server layer, making it possible to distribute OTP as a standalone JAR \"Long-distance\" mode for large graphs, including bidirectional goal direction heuristic. Simplified Maven project structure with less submodules GTFS-RT trip update support, including streaming incremental data, which directly affects route optimization 0.10.0 (2014-03-18) This release was made to consolidate all the development that had occurred with a 0.9.x-SNAPSHOT Maven version. The changes were very significant and it was not appropriate to tag them as a minor bugfix release after the 0.9 tag. Though this release was performed at the same time as 0.11.0, it represents a much earlier stage in the development of OTP. 0.7.0 (2012-04-29) Bike rental support (thanks Laurent Gr\u00e9goire) Realtime bike rental availability feed support Updated to new version of One Bus Away GTFS/CSV, fixing timezone and string interning issues (thanks Brian Ferris) Bugfixes in area routing, OSM loading, nonexistant NED tiles, route short names Dutch and French language updates Catch negative edge weights due to broken GTFS Significant (10-20%) speedup by moving a field into StateData (thanks Laurent Gr\u00e9goire) 0.6.0 (2012-04-25) area routing more lenient parsing of times new directions icon set with SVG sources (thanks Laurent G) 0.5.4 (2012-04-06) catch 0 divisors in NED builder, preventing NaN propagation to edge lengths avoid repeated insertion of edges into edge lists, which are now threadsafe edge sets identity equality for edges bounding box check in UnifiedCoverage (speed up NED loading) Dutch API messages elevation override fix less verbose graph builder (be sure to check graphbuilder annotation summary) replacement streets given names geocoder bug fix (thanks Laurent Gregoire) git commit IDs included in MavenVersion, allowing clearer OTP/Graph version mismatch warnings fix problems with immediate reboarding and unexpected edges in itinerary builder favicon (thanks Joel Haasnoot) Legs in API response have TripId (for realtime information) Polish locale (thanks \u0141ukasz Witkowski) transfers.txt can define station paths, entry costs for stations allow loading a base graph into graphbuilder instead of starting from scratch 0.5.3 (2012-03-23) GTFS loader now loads feeds one-at-a-time, allowing per-feed configuration half-written graph files are now deleted on graph build error DST issue OTP-side fixes, tests adjusted to use timezones updated French translation fixed problem with loop ways in OSM graph coherency checking improved OSM floor number handling handle units in ele tags ferry icons (thanks Joel Haasnoot) mapbox streets tile layer is now the default complete Dutch translation 0.5.2 (2012-03-20) hop speed/distance checks, duplicate shape point filtering, etc. 0.5.1 (2012-03-16) more transit index features default agencyIDs now determined on a per-feed basis fixed fare overflow problem fixed bug in loop road turn conversion additional graphbuilder warnings and annotations fixed a batch of bugs found by fixbugs 0.5.0 (2012-03-09) stop codes, zones, and agency names in planner responses encapsulation of edge list modifications expanded edge and vertex type hierarchy use mapquest OSM server by default Turkish locale (thanks Hasan Tayyar Be\u015fik) German and Italian locales (thanks Gerardo Carrieri) bookmarkable trip URLs (thanks Matt Conway) elevator and OSM level support (thanks Matt Conway) BART/Muni fare service release and javadoc/apidoc publishing automation graph versioning based on Maven artifact version API for browsing graph internals improved stop linking optional island removal graphbuilder step and of course, lots of bugfixes 0.4.4 (2012-02-06) Release in anticipation of upcoming merges.","title":"Changelog"},{"location":"Changelog/#changelog","text":"","title":"Changelog"},{"location":"Changelog/#150-2020-11-27","text":"Add application/x-protobuf to accepted protobuf content-types (#2839) Add Way Property Set for the UK (#2818) Fixes surefire test failure during build (#2816) Improve documentation for mode routing parameter (#2809) Disable linking from already linked stops (#2372) Optimize elevation calculations","title":"1.5.0 (2020-11-27)"},{"location":"Changelog/#14-2019-07-30","text":"Remove Open Traffic prototype code (#2698) Improved configuration documentation Update onebusaway-gtfs to latest version from OBA project (#2636) Remove the coupling to OneBusAway GTFS within OTP's internal model by creating new classes replacing the external classes (#2494) Allow OTP to search more service days for transit service (#2592) Allow itineraries in response to be sorted by duration (#2593) Add support for GTFS-flex services: flag stops, deviated-route service, and call-and-ride (#2603) Fix reverse optimization bug (#2653, #2411) increase GTFS-realtime feeds size limit from 64MB to 2G (#2738) Fix XML response serialization (#2685) Refactor InterleavedBidirectionalHeuristic (#2671) Add \"Accept\" headers to GTFS-RT HTTP requests (#2796) Fix minor test failure against BANO geocoder (#2798) Fix frequency bounds checking (#2540) Fix JTS coordinate order for Polygons/Polylines (#2784) Add JAXB API to allow compilation under Java 11 Remove dependency on Conveyal jackson2-geojson Changed calculation of slope costs (#2579) Replace Java built in serialization with faster Kryo (#2681) Support OSM highway=razed tag (#2660) Memory leak fix (#2655) Add bicimad bike rental updater (#2503) Add Smoove citybikes updater (#2515) Switched to single license file, removing all OTP and OBA file license headers","title":"1.4 (2019-07-30)"},{"location":"Changelog/#13-2018-08-03","text":"Fix stop linking to only one edge of platform (#2472) Log and allow changing number of HTTP handler threads Update Dutch base fare from 89 to 90 cents (#2608) Add Dutch fare service (#2571) Revise unit tests to use less memory Run all graph updater setup methods sequentially (#2545) Allow vehicle rental systems with cars (stopgap parameter on bike rental) Bump R5 version to get newer gtfs-lib and FST serialization Move stopClusterMode parameter from routing config to build config (#2558) Update encrypted Maven artifact signing key (it expired) Clean up logging Remove/update deprecated HTTPClient, add missing SSL ciphers (#2451) Make maxTransfer options configurable through scripting API (#2507) Fix scripts when entity IDs contain colons (#2474) Add HTML report for stops more than 20m from linked road (#2460) Update fares in NycFareServiceImpl (#2466) Compact legs NPE fix (#2449) (#2490) Docs: elevation data configuration, USGS DEM files Docs: Update list of deployments Docs: API, list of deployments, usage stats and tutorials Docs: Update leadership committee listing following Boston Summit Docs: Update OTP logo (Thanks Kate Chanba!)","title":"1.3 (2018-08-03)"},{"location":"Changelog/#12-2017-09-18","text":"Add support for consuming GBFS bike-rental availability feeds. #2458 Add GBFS configuration example Add flag for including requested start/end time in maxHours in planner API. #2457 Add maxTransferDistance graph builder parameter Add option for filtering non-pickup stops in TransitIndex stop times functions. #2377 Support foot/bicycle=discouraged OSM tag. #2415 Improve linking of transit platforms to connecting access ways. #2422 / #2428 Fix bug when building graph with parent station transfers. #2404 / #2410 Fix bugs in park and ride search. #2424 Support different stop ID formats in field trip module Update URL in BANO geocoding module. #2438 / #2439 Add more debug information related to trips matching using GTFS-RT feed. #2432 Update default PATH_NOT_FOUND message to new wording developed w/ TriMet. #2355 Update Travis build configuration to not attempt GPG operations. #2441 Fix javadoc URL in scripting documentation. #2437 Automatically link to GitHub issues in Changelog. #2426 Expose FeedInfo objects in the Index API #2456 Changes to Puget Sound region fare calculation #2484 Fix coordinatates when clustering by parent station #2447 Allow setting OSM Way Properties from build-config.json #2389 Optionally compact (\"reverse-optimize\") results with complete reverse search #2449 Add updater for urbaninfrastructure city bikes #2448 Miscellaneous documentation updates","title":"1.2 (2017-09-18)"},{"location":"Changelog/#11-2017-03-16","text":"Deploy to Sonatype OSSRH and Maven Central Documentation updates including repo links New router-config stopClusterMode: clustering by parent station or geography #2364 Spanish and Portuguese UI Translations In TimeSurface API, serialize travel times to every point when detail=true Make OSM highway=corridor pedestrian routable Fix GraphIndex.stopTimesForStop to search on the request day rather than now Update GraphQL to latest version and improve support for complex arguments #2367 Add support for operationName to the graphql endpoint Fix findClosestStopsByWalking, properly set RoutingContext Fixed major routing problem where dead-end SimpleTransfers blocked walking paths #2414 Created Github issue template Avoid negative elevation figures: Compute ellipsoid-geoid offset and optionally apply to elevation calculations #2301 Fix VCub bike share updater using new API variable names. Fix spurious different-day warning #2399 Shutdown hook to gracefully shut down Grizzly #2384 Added headsign attribute for stoptimes in GraphQL #2224 Allow Cars on highway=*;bicycle=designated #2374 Expose PruneFloatingIslands parameters in build-config.json Lazy initialization of stop clusters where needed Include Agency/Route branding in responses Include turn-by-turn walking directions for transfer legs #1707 Output error when edge lengths are negative, and set them to 1mm Add disableAlertFiltering API flag #2351 Do not show arrival times at terminal stops in stop time viewer #2357 Index API now returns stop information URL, enabling hyperlinks in trip viewer #2352 Remove all unused model classes for index API #1301 Apply an interlining fix from 0.10 branch Allow quoted search phrases in the Lucene search #2279 Re-implement maxHours filter #2332 Properly set wheelchairAccessible on area edges Fixed file URL in test #2339 Add details field to fares, listing which legs each fare applies to #1699","title":"1.1 (2017-03-16)"},{"location":"Changelog/#10-2016-09-09","text":"Fix problem with missing embedded router-configs. Check whether trips have been banned when applying in-seat transfers (interlining). Load embedded config for existing graphs on disk. Apply max walk distance to transfers, not just initial and final walk. Remove Conveyal tiles from client (which was getting expensive), add free Carto/MapZen tiles. Fixed headsigns: in itineraries, headsign for a leg used to always be the last stop. Updated default map tile sets in the client because Mapquest is no longer gratis. Fix problem with empty list ??? #1873 Rewrite of intermediate places handling in GraphPathFinder. Original request is cloned for each intermediate path. Routes in GraphQL API Change \"type\" to \"mode\" and add \"type\" as route type to Route for GraphQL Add effective end date to alerts (from HSL). Rutebanken Citybike bike share. Correct TPEG transport modes TPEG 401 and 402 to be \"subway\". Ignore exceptions caused by errors in OSM linear rings. Updated to version 2.18 of Jersey to fix hanging threads in Grizzly. Removed confusing \"Busish\" and \"Trainish\" pseudo-modes. FareService for Seattle: allow specifying fares in GTFS instead of hard-coding them in Java. Senior/youth fare prices are given in an extra column in fare attributes. Per-trip fares are taken into consideration when calculating fares in this region. Update new linker to link to transitStops if no streets are found. Show the name supplied in the request for the origin/destination points in the response. Throw a trivialPath exception if start/end point are on the same edge. Switch to only use the new SimpleStreetLinker, even for search start and end points. Completely removed old linker classes. Changes for proper handling of wheelchairs and bicycles at start and end points. Properly handle null timetableSnapshots when there is no real-time data.","title":"1.0 (2016-09-09)"},{"location":"Changelog/#020-2016-06-10","text":"Re-enabled Enunciate, which works properly with OTP now. This means we have auto-generated API docs. Make headsign and block ID visible in the Stop Viewer. NYC fare service: filter out non-NYC agencies. Optionally log all requests to a file. Make max distance for in-seat transfers (interlining) configurable. Previously it was hardcoded at 200m. Polish translation for web client. Introduced bikeShareId in trip plans (separate from stopIds). Support for ShareBike bike rental system in Oslo, Drammen, Trondheim, Milan, Barcelona and Mexico City among others. Changed default waitAtBeginningFactor and timeouts. Show alert in client when itinerary departure date differs from search date. Exposed realtimeState in GraphQL responses. Fixed a routerConfig NullPointerException. Support for San Francisco bike share from leoromanovsky. GraphQL API for most transit data from hannesj. Disallow shortcuts through multiple StationStopEdges. Add support for airplanes (from HSL) Major simplification and correction of the longDistance heuristic, removed obsolete runState.options.heuristicWeight. Return default OSM level for ways that are not found. Profile routing: use earliest arrival objective function on-street, properly handle TrivialPathExceptions. Fixed ID matching when applying AlertPatches. Fixed banning of agencies in multi agency feeds. More coherent handling of feed IDs as scope for GTFS IDs. Added transit service start and end timestamps to BuildInfo. Handle embeded router configuration for POSTed graphs and zips for building. Simplified router-config handling. Properly lazy-initialize profile routing stopClusters. Added stop clusters to the Index API. Completely removed the ill-advised path parser system, which was too clever for its own good. Sort itineraries by total travel time rather than in-transit time. Rental bikes: allow loading generic KML. Removed the experimental TransportNetwork classes, which shared no code with the rest of OTP and were duplicated in the R5 project. There are still some elements that can be cleaned out when only R5 is used by Conveyal's analysis system. The broker code in OTP is now able to start up R5 workers for Analyst. Use the Conveyal fork of the OBA GTFS loader, so that we can add our own extensions to GTFS. Updated docs to offer Conveyal Maven repo as a place to get prebuilt OTP.","title":"0.20 (2016-06-10)"},{"location":"Changelog/#0190-2016-05-25","text":"TODO","title":"0.19.0 (2016-05-25)"},{"location":"Changelog/#0180-2015-05-29","text":"Ability to load elevation from projected GeoTIFF Clarified axis order for unprojected GeoTIFFs Stop viewer and car distance fixed in client Server-side localization improvements Proper names for intersections JSON config for loading bikeshare and park and ride lots from OSM More ways to fetch isochrones Fixed frequency-based routing in repeated RAPTOR Calculate graph envelope at build time not runtime Fixed slow excessive HashGrid search Readthedocs documentation updates","title":"0.18.0 (2015-05-29)"},{"location":"Changelog/#0170-2015-05-14","text":"Allow fetching arrivals/departures over a particular time window Completely new spatial analysis implementation: repeated RAPTOR search at every minute in a departure time window More reproducible spatial analysis results across similar graphs, thanks to more consistent splitting of streets etc. Sigmoidal accessibility metric rolloff (rather than hard-edged cutoff) Correction of equirectangular projection used in spatial analysis Improved, simplified, deterministic linking of stops into the street network","title":"0.17.0 (2015-05-14)"},{"location":"Changelog/#0160-2015-05-07","text":"Several improvements to OSM tag based traversal permissions Scripting documentation Accept TIFF files whose names end in .tiff not .tif Store distances (not times) in Analyst Samples to allow variable walk speed Fixed bug in graph auto-scanning Fixed client-side bug in first and last itinerary buttons OTP startup scripts no longer use wildcards Transit, bike rental, and parking linking done in one module Elevation tiles for the US can be fetched from Amazon S3 Bumped language level to Java 8 (lambda functions, method references, collection streams)","title":"0.16.0 (2015-05-07)"},{"location":"Changelog/#0150-2015-04-14","text":"Fare module for Seattle JSON fare module and OSM street naming configuration Significant improvements to speed and result quality of Profile Routing Support for added and modified GTFS-RT trips (thanks Jaap Koelewijn of DAT Mobility and Plannerstack) Detailed edge lists in profile routing responses (for Transitive.js) Support for multiple access modes including bike rental in profile routing Fixes to graph reloading via web API Improved comments in code and documentation of PointSets Pulled MapDB GTFS loader out into a separate repo Working artifact version was 0.15.0-SNAPSHOT instead of 1.0.0-SNAPSHOT (anticipating frequent point releases)","title":"0.15.0 (2015-04-14)"},{"location":"Changelog/#0140-2015-03-28","text":"JSON configuration of graph building and routers Began moving documentation (including this changelog) into the OTP repo and rewriting it page by page. It is built statically from Markdown using mkdocs and published on readthedocs. Street edge lists and bike rental station IDs in profile routing results (allows better rendering) Improved correctness of profile routing Qualified modes including rented bikes work in profile routing Simplification of qualified mode sets Elevation models are loaded from TIFFs in graph directory Tiles for differences between TimeSurfaces Restructured relationship between Routers and Graphs Various changes enabling use of Analyst features in a cluster computing environment. Removed several single-implementation interfaces, factories, services and other superfluous abstractions Various client fixes related to the transit index API Revised nearby stops logic and transfer generation to eliminate useless transfer edges New Index API endpoints for geometries, transfers etc. Isochrone generation fixes Default mode of operation is now \u201clong distance mode\u201d Process for finding alternative routes is now based on banning trips and retrying, while reusing the heuristic Optimization objective functions are swappable, and have been simplified and corrected All client Javascript librariess are now pulled from a CDN Dutch BAG and French BANO geocoders Bus to street matching improvements Complete MapDB based GTFS and OSM loader libraries (will become separate projects, not yet connected to OTP graph builder) API documentation generation working again Disable some time consuming graph building steps by default Finnish and Swedish translations Subway-specific JSON configuration options (street to platform time) Realtime fetch / streaming configurable via JSON Stairs reluctance is much higher when carrying a bike Graph visualizer routing progress animates when a search is triggered via the web API Assume WGS84 (spherical distance calculations) everywhere Removed custom motor vehicle (which was unmaintained and not documented) Ability to poll for bike rental locations only once at startup Stoptimes are fetched for a specific service day in index API Bicycle triangle support in profile routing Proper handling of multiple access modes with different speeds in profile routing Command line option to output OTP's version","title":"0.14.0 (2015-03-28)"},{"location":"Changelog/#0130-2014-12-05","text":"Detect apparent errors in GTFS interlining Long distance mode: use a pure weight-based state comparison, and use trip-banning retrying logic to get multiple paths. This compromises correctness somewhat but brings search times back within reason for large regional graphs. Also, we create significantly less SimpleTransfers. Progress on GTFS reading and writing library (not yet used by OTP). Bug fixes for tiny street edges, time zones. Deployment of artifacts to maven.conveyal.com via S3. Handle park and ride lots that have roads running through them, but don't share nodes with those roads.","title":"0.13.0 (2014-12-05)"},{"location":"Changelog/#0121-2014-11-17","text":"Fixed threading problem caused by graph visualization instrumentation #1611 Fixed 'unconnected areas' infinite loop #1605","title":"0.12.1 (2014-11-17)"},{"location":"Changelog/#0120-2014-11-11","text":"Graph building from zipball of data sent over the wire OTP-specific GTFS loader library with error checking and recovery Bike and car park and ride improvements Stable hash codes for stop patterns and trips Bicycle safety and wheelchair access tile generators Newer versions of Grizzly, Jackson, and Enunciate (documentation generation now works) Redesigned HashGrid spatial index Significant reduction in graph size in memory and on disk Improved internationalization Ability to pause and step search in graph visualizer Additional graph visualizer modes for spotting overbranching Movement toward 1.0 web services API Kiss and Ride Complete removal of Spring Complete removal of Lombok CORS replaces JSONP Pointset classes for dealing with one-to-many calculations and accessibility calculations Experimental \"Profile routing\" which enumerates reasonable route combinations over a time range rather than exact itineraries Single-module Maven build (complete elimination of submodules) Alternate Gradle build script full internationalization of the map-based web client basic Lucene-based built-in geocoder","title":"0.12.0 (2014-11-11)"},{"location":"Changelog/#0110-2014-03-24","text":"Built-in HTTP server layer, making it possible to distribute OTP as a standalone JAR \"Long-distance\" mode for large graphs, including bidirectional goal direction heuristic. Simplified Maven project structure with less submodules GTFS-RT trip update support, including streaming incremental data, which directly affects route optimization","title":"0.11.0 (2014-03-24)"},{"location":"Changelog/#0100-2014-03-18","text":"This release was made to consolidate all the development that had occurred with a 0.9.x-SNAPSHOT Maven version. The changes were very significant and it was not appropriate to tag them as a minor bugfix release after the 0.9 tag. Though this release was performed at the same time as 0.11.0, it represents a much earlier stage in the development of OTP.","title":"0.10.0 (2014-03-18)"},{"location":"Changelog/#070-2012-04-29","text":"Bike rental support (thanks Laurent Gr\u00e9goire) Realtime bike rental availability feed support Updated to new version of One Bus Away GTFS/CSV, fixing timezone and string interning issues (thanks Brian Ferris) Bugfixes in area routing, OSM loading, nonexistant NED tiles, route short names Dutch and French language updates Catch negative edge weights due to broken GTFS Significant (10-20%) speedup by moving a field into StateData (thanks Laurent Gr\u00e9goire)","title":"0.7.0 (2012-04-29)"},{"location":"Changelog/#060-2012-04-25","text":"area routing more lenient parsing of times new directions icon set with SVG sources (thanks Laurent G)","title":"0.6.0 (2012-04-25)"},{"location":"Changelog/#054-2012-04-06","text":"catch 0 divisors in NED builder, preventing NaN propagation to edge lengths avoid repeated insertion of edges into edge lists, which are now threadsafe edge sets identity equality for edges bounding box check in UnifiedCoverage (speed up NED loading) Dutch API messages elevation override fix less verbose graph builder (be sure to check graphbuilder annotation summary) replacement streets given names geocoder bug fix (thanks Laurent Gregoire) git commit IDs included in MavenVersion, allowing clearer OTP/Graph version mismatch warnings fix problems with immediate reboarding and unexpected edges in itinerary builder favicon (thanks Joel Haasnoot) Legs in API response have TripId (for realtime information) Polish locale (thanks \u0141ukasz Witkowski) transfers.txt can define station paths, entry costs for stations allow loading a base graph into graphbuilder instead of starting from scratch","title":"0.5.4 (2012-04-06)"},{"location":"Changelog/#053-2012-03-23","text":"GTFS loader now loads feeds one-at-a-time, allowing per-feed configuration half-written graph files are now deleted on graph build error DST issue OTP-side fixes, tests adjusted to use timezones updated French translation fixed problem with loop ways in OSM graph coherency checking improved OSM floor number handling handle units in ele tags ferry icons (thanks Joel Haasnoot) mapbox streets tile layer is now the default complete Dutch translation","title":"0.5.3 (2012-03-23)"},{"location":"Changelog/#052-2012-03-20","text":"hop speed/distance checks, duplicate shape point filtering, etc.","title":"0.5.2 (2012-03-20)"},{"location":"Changelog/#051-2012-03-16","text":"more transit index features default agencyIDs now determined on a per-feed basis fixed fare overflow problem fixed bug in loop road turn conversion additional graphbuilder warnings and annotations fixed a batch of bugs found by fixbugs","title":"0.5.1 (2012-03-16)"},{"location":"Changelog/#050-2012-03-09","text":"stop codes, zones, and agency names in planner responses encapsulation of edge list modifications expanded edge and vertex type hierarchy use mapquest OSM server by default Turkish locale (thanks Hasan Tayyar Be\u015fik) German and Italian locales (thanks Gerardo Carrieri) bookmarkable trip URLs (thanks Matt Conway) elevator and OSM level support (thanks Matt Conway) BART/Muni fare service release and javadoc/apidoc publishing automation graph versioning based on Maven artifact version API for browsing graph internals improved stop linking optional island removal graphbuilder step and of course, lots of bugfixes","title":"0.5.0 (2012-03-09)"},{"location":"Changelog/#044-2012-02-06","text":"Release in anticipation of upcoming merges.","title":"0.4.4 (2012-02-06)"},{"location":"Configuration/","text":"Configuring OpenTripPlanner Base directory The OTP base directory defaults to /var/otp . Unless you tell OTP otherwise, all other configuration, input files and storage directories will be sought immediately beneath this one. This prefix follows UNIX conventions so it should work in Linux and Mac OSX environments, but it is inappropriate in Windows and where the user running OTP either cannot obtain permissions to /var or simply wishes to experiment within his or her home directory rather than deploy a system-wide server. In these cases one should use the basePath switch when starting up OTP to override the default. For example: --basePath /home/username/otp on a Linux system, --basePath /Users/username/otp in Mac OSX, or --basePath C:\\Users\\username\\otp in Windows. Routers A single OTP instance can handle several regions independently. Each of these separate (but potentially geographically overlapping) services is called a router and is referred to by a short unique ID such as 'newyork' or 'paris'. Each router has its own subdirectory in a directory called 'graphs' directly under the OTP base directory, and each router's directory is always named after its router ID. Thus, by default the files for the router 'tokyo' will be located at /var/otp/graphs/tokyo . Here is an example directory layout for an OTP instance with two routers, one for New York City and one for Portland, Oregon: /var/otp \u251c\u2500\u2500 cache \u2502 \u2514\u2500\u2500 ned \u2514\u2500\u2500 graphs \u251c\u2500\u2500 nyc \u2502 \u251c\u2500\u2500 build-config.json \u2502 \u251c\u2500\u2500 Graph.obj \u2502 \u251c\u2500\u2500 long-island-rail-road_20140216_0114.zip \u2502 \u251c\u2500\u2500 mta-new-york-city-transit_20130212_0419.zip \u2502 \u251c\u2500\u2500 new-york-city.osm.pbf \u2502 \u2514\u2500\u2500 port-authority-of-new-york-new-jersey_20150217_0111.zip \u2514\u2500\u2500 pdx \u251c\u2500\u2500 build-config.json \u251c\u2500\u2500 Graph.obj \u251c\u2500\u2500 gtfs.zip \u251c\u2500\u2500 portland_oregon.osm.pbf \u2514\u2500\u2500 router-config.json You can see that each of these subdirectories contains one or more GTFS feeds (which are just zip files full of comma-separated tables), a PBF street map file, some JSON configuration files, and another file called Graph.obj . On startup, OTP scans router directories for input and configuration files, and can optionally store the resulting combined representation of the transportation network as Graph.obj in the same directory to avoid re-processing the data the next time it starts up. The cache directory is where OTP will store its local copies of resources fetched from the internet, such as US elevation tiles. System-wide vs. graph build vs. router configuration OTP is configured via JSON files. The file otp-config.json is placed in the OTP base directory and contains settings that affect the entire OTP instance. Each router within that instance is configured using two other JSON files placed alongside the input files (OSM, GTFS, elevation data etc.) in the router's directory. These router-level config files are named build-config.json and router-config.json . Each configuration option within each of these files is optional, as are all three of the files themselves. If any option or an entire file is missing, reasonable defaults will be applied. Some parts of the process that loads the street and transit network description are time consuming and memory-hungry. To avoid repeating these slow steps every time OTP starts up, we can trigger them manually whenever the input files change, saving the resulting transportation network description to disk. We call this prepared product a graph (following mathematical terminology ), and refer to these \"heavier\" steps as graph building . They are controlled by build-config.json . There are many other details of OTP operation that can be modified without requiring the potentially long operation of rebuilding the graph. These run-time configuration options are found in router-config.json . Graph build configuration This table lists the possible settings that can be defined in a build-config.json file. Sections follow that describe particular settings in more depth. config key description value type value default notes htmlAnnotations Generate nice HTML report of Graph errors/warnings (annotations) boolean false transit Include all transit input files (GTFS) from scanned directory boolean true useTransfersTxt Create direct transfer edges from transfers.txt in GTFS, instead of based on distance boolean false parentStopLinking Link GTFS stops to their parent stops boolean false stationTransfers Create direct transfers between the constituent stops of each parent station boolean false stopClusterMode Stop clusters can be built in one of two ways, either by geographical proximity and name, or according to a parent/child station topology, if it exists enum proximity options: proximity , parentStation subwayAccessTime Minutes necessary to reach stops served by trips on routes of route_type=1 (subway) from the street double 2.0 units: minutes streets Include street input files (OSM/PBF) boolean true embedRouterConfig Embed the Router config in the graph, which allows it to be sent to a server fully configured over the wire boolean true areaVisibility Perform visibility calculations. If this is true OTP attempts to calculate a path straight through an OSM area using the shortest way rather than around the edge of it. (These calculations can be time consuming). boolean false platformEntriesLinking Link unconnected entries to public transport platforms boolean false matchBusRoutesToStreets Based on GTFS shape data, guess which OSM streets each bus runs on to improve stop linking boolean false fetchElevationUS Download US NED elevation data and apply it to the graph boolean false elevationBucket If specified, download NED elevation tiles from the given AWS S3 bucket object null provide an object with accessKey , secretKey , and bucketName for AWS S3 elevationUnitMultiplier Specify a multiplier to convert elevation units from source to meters double 1.0 see Elevation unit conversion readCachedElevations If true, reads in pre-calculated elevation data. boolean true see Elevation Data Calculation Optimizations writeCachedElevations If true, writes the calculated elevation data. boolean false see Elevation Data Calculation Optimizations multiThreadElevationCalculations If true, the elevation module will use multi-threading during elevation calculations. boolean false see Elevation Data Calculation Optimizations fares A specific fares service to use object null see fares configuration osmNaming A custom OSM namer to use object null see custom naming osmWayPropertySet Custom OSM way properties string default options: default , norway , uk staticBikeRental Whether bike rental stations should be loaded from OSM, rather than periodically dynamically pulled from APIs boolean false staticParkAndRide Whether we should create car P+R stations from OSM data boolean true staticBikeParkAndRide Whether we should create bike P+R stations from OSM data boolean false maxHtmlAnnotationsPerFile If number of annotations is larger then specified number annotations will be split in multiple files int 1,000 maxInterlineDistance Maximal distance between stops in meters that will connect consecutive trips that are made with same vehicle int 200 units: meters islandWithoutStopsMaxSize Pruning threshold for islands without stops. Any such island under this size will be pruned int 40 islandWithStopsMaxSize Pruning threshold for islands with stops. Any such island under this size will be pruned int 5 banDiscouragedWalking should walking should be allowed on OSM ways tagged with foot=discouraged\" boolean false banDiscouragedBiking should walking should be allowed on OSM ways tagged with bicycle=discouraged\" boolean false maxTransferDistance Transfers up to this length in meters will be pre-calculated and included in the Graph double 2,000 units: meters extraEdgesStopPlatformLink add extra edges when linking a stop to a platform, to prevent detours along the platform edge boolean false This list of parameters in defined in the code for GraphBuilderParameters . Reaching a subway platform The boarding locations for some modes of transport such as subways and airplanes can be slow to reach from the street. When planning a trip, we need to allow additional time to reach these locations to properly inform the passenger. For example, this helps avoid suggesting short bus rides between two subway rides as a way to improve travel time. You can specify how long it takes to reach a subway platform // build-config.json { \"subwayAccessTime\" : 2.5 } Stops in GTFS do not necessarily serve a single transit mode, but in practice this is usually the case. This additional access time will be added to any stop that is visited by trips on subway routes (GTFS route_type = 1). This setting does not generalize well to airplanes because you often need much longer to check in to a flight (2-3 hours for international flights) than to alight and exit the airport (perhaps 1 hour). Therefore there is currently no per-mode access time, it is subway-specific. Transferring within stations Subway systems tend to exist in their own layer of the city separate from the surface, though there are exceptions where tracks lie right below the street and transfers happen via the surface. In systems where the subway is quite deep and transfers happen via tunnels, the time required for an in-station transfer is often less than that for a surface transfer. A proposal was made to provide detailed station pathways in GTFS but it is not in common use. One way to resolve this problem is by ensuring that the GTFS feed codes each platform as a separate stop, then micro-mapping stations in OSM. When OSM data contains a detailed description of walkways, stairs, and platforms within a station, GTFS stops can be linked to the nearest platform and transfers will happen via the OSM ways, which should yield very realistic transfer time expectations. This works particularly well in above-ground train stations where the layering of non-intersecting ways is less prevalent. Here's an example in the Netherlands: View Larger Map When such micro-mapping data is not available, we need to rely on information from GTFS including how stops are grouped into stations and a table of transfer timings where available. During the graph build, OTP can create preferential connections between each pair of stops in the same station to favor in-station transfers: // build-config.json { \"stationTransfers\" : true } Note that this method is at odds with micro-mapping and might make some transfers artificially short. Elevation data OpenTripPlanner can \"drape\" the OSM street network over a digital elevation model (DEM). This allows OTP to draw an elevation profile for the on-street portion of itineraries, and helps provide better routing for bicyclists. It even helps avoid hills for walking itineraries. DEMs are usually supplied as rasters (regular grids of numbers) stored in image formats such as GeoTIFF. U.S. National Elevation Dataset In the United States, a high resolution National Elevation Dataset is available for the entire territory. The US Geological Survey (USGS) delivers this dataset in tiles via a somewhat awkward heavyweight web-based GIS which generates and emails you download links. OpenTripPlanner contains a module which will automatically contact this service and download the proper tiles to completely cover your transit and street network area. This process is rather slow (download is around 1.5 hours, then setting elevation for streets takes about 5 minutes for the Portland, Oregon region), but once the tiles are downloaded OTP will keep them in local cache for the next graph build operation. To auto-download NED tiles when building your graph, add the following line to build-config.json in your router directory: // build-config.json { \"fetchElevationUS\" : true } You may also want to add the --cache <directory> command line parameter to specify a custom NED tile cache location. NED downloads take quite a long time and slow down the graph building process. The USGS will also deliver the whole dataset in bulk if you send them a hard drive . OpenTripPlanner contains another module that will then automatically fetch data in this format from an Amazon S3 copy of your bulk data. You can configure it as follows in build-config.json : { \"elevationBucket\" : { \"accessKey\" : \"your-aws-access-key\" , \"secretKey\" : \"corresponding-aws-secret-key\" , \"bucketName\" : \"ned13\" } } Geoid Difference With some elevation data, the elevation values are specified as relative to the a geoid (irregular estimate of mean sea level). See issue #2301 for detailed discussion of this. In these cases, it is necessary to also add this geoid value onto the elevation value to get the correct result. OTP can automatically calculate these values in one of two ways. The first way is to use the geoid difference value that is calculated once at the center of the graph. This value is returned in each trip plan response in the ElevationMetadata field. Using a single value can be sufficient for smaller OTP deployments, but might result in incorrect values at the edges of larger OTP deployments. If your OTP instance uses this, it is recommended to set a default request value in the router-config.json file as follows: // router-config.json { \"routingDefaults\" : { \"geoidElevation \" : true } } The second way is to precompute these geoid difference values at a more granular level and include them when calculating elevations for each sampled point along each street edge. In order to speed up calculations, the geoid difference values are calculated and cached using only 2 significant digits of GPS coordinates. This is more than enough detail for most regions of the world and should result in less than one meter of difference in areas that have large changes in geoid difference values. To enable this, include the following in the build-config.json file: // build-config.json { \"includeEllipsoidToGeoidDifference\" : true } If the geoid difference values are precomputed, be careful to not set the routing resource value of geoidElevation to true in order to avoid having the graph-wide geoid added again to all elevation values in the relevant street edges in responses. Other raster elevation data For other parts of the world you will need a GeoTIFF file containing the elevation data. These are often available from national geographic surveys, or you can always fall back on the worldwide Space Shuttle Radar Topography Mission (SRTM) data. This not particularly high resolution (roughly 30 meters horizontally) but it can give acceptable results. Simply place the elevation data file in the directory with the other graph builder inputs, alongside the GTFS and OSM data. Make sure the file has a .tiff or .tif extension, and the graph builder should detect its presence and apply the elevation data to the streets. OTP should automatically handle DEM GeoTIFFs in most common projections. You may want to check for elevation-related error messages during the graph build process to make sure OTP has properly discovered the projection. If you are using a DEM in unprojected coordinates make sure that the axis order is (longitude, latitude) rather than (latitude, longitude). Unfortunately there is no reliable standard for WGS84 axis order, so OTP uses the same axis order as the above-mentioned SRTM data, which is also the default for the popular Proj4 library. DEM files(USGS DEM) is not supported by OTP, but can be converted to GeoTIFF with tools like GDAL . Use gdal_merge.py -o merged.tiff *.dem to merge a set of dem files into one tif file. See Interline PlanetUtils for a set of scripts to download, merge, and resample Mapzen/Amazon Terrain Tiles . Elevation unit conversion By default, OTP expects the elevation data to use metres. However, by setting elevationUnitMultiplier in build-config.json , it is possible to define a multiplier that converts the elevation values from some other unit to metres. // build-config.json { // Correct conversation multiplier when source data uses decimetres instead of metres \"elevationUnitMultiplier\" : 0.1 } Elevation Data Calculation Optimizations Calculating elevations on all StreetEdges can take a dramatically long time. In a very large graph build for multiple Northeast US states, the time it took to download the elevation data and calculate all of the elevations took 5,509 seconds (roughly 1.5 hours). If you are using cloud computing for your OTP instances, it is recommended to create prebuilt images that contain the elevation data you need. This will save time because all of the data won't need to be downloaded. However, the bulk of the time will still be spent calculating elevations for all of the street edges. Therefore, a further optimization can be done to calculate and save the elevation data during a graph build and then save it for future use. Reusing elevation data from previous builds In order to write out the precalculated elevation data, add this to your build-config.json file: // build-config.json { \"writeCachedElevations\" : true } After building the graph, a file called cached_elevations.obj will be written to the cache directory. By default, this file is not written during graph builds. There is also a graph build parameter called readCachedElevations which is set to true by default. In graph builds, the elevation module will attempt to read the cached_elevations.obj file from the cache directory. The cache directory defaults to /var/otp/cache , but this can be overriden via the CLI argument --cache <directory> . For the same graph build for multiple Northeast US states, the time it took with using this predownloaded and precalculated data became 543.7 seconds (roughly 9 minutes). The cached data is a lookup table where the coordinate sequences of respective street edges are used as keys for calculated data. It is assumed that all of the other input data except for the OpenStreetMap data remains the same between graph builds. Therefore, if the underlying elevation data is changed, or different configuration values for elevationUnitMultiplier or includeEllipsoidToGeoidDifference are used, then this data becomes invalid and all elevation data should be recalculated. Over time, various edits to OpenStreetMap will cause this cached data to become stale and not include new OSM ways. Therefore, periodic update of this cached data is recommended. Configuring multi-threading during elevation calculations For unknown reasons that seem to depend on data and machine settings, it might be faster to use a single processor. For this reason, multi-threading of elevation calculations is only done if multiThreadElevationCalculations is set to true. To enable multi-threading in the elevation module, add the following to the build-config.json file: // build-config.json { \"multiThreadElevationCalculations\" : true } Fares configuration By default OTP will compute fares according to the GTFS specification if fare data is provided in your GTFS input. For more complex scenarios or to handle bike rental fares, it is necessary to manually configure fares using the fares section in build-config.json . You can combine different fares (for example transit and bike-rental) by defining a combinationStrategy parameter, and a list of sub-fares to combine (all fields starting with fare are considered to be sub-fares). // build-config.json { // Select the custom fare \"seattle\" \"fares\" : \"seattle\" , // OR this alternative form that could allow additional configuration \"fares\" : { \"type\" : \"seattle\" } } // build-config.json { \"fares\" : { // Combine two fares by simply adding them \"combinationStrategy\" : \"additive\" , // First fare to combine \"fare0\" : \"new-york\" , // Second fare to combine \"fare1\" : { \"type\" : \"bike-rental-time-based\" , \"currency\" : \"USD\" , \"prices\" : { // For trip shorter than 30', $4 fare \"30\" : 4.00 , // For trip shorter than 1h, $6 fare \"1:00\" : 6.00 } } // We could also add fareFoo, fareBar... } } The current list of custom fare type is: bike-rental-time-based - accepting the following parameters: currency - the ISO 4217 currency code to use, such as \"EUR\" or \"USD\" , prices - a list of {time, price}. The resulting cost is the smallest cost where the elapsed time of bike rental is lower than the defined time. san-francisco (no parameters) new-york (no parameters) seattle (no parameters) The current list of combinationStrategy is: additive - simply adds all sub-fares. OSM / OpenStreetMap configuration It is possible to adjust how OSM data is interpreted by OpenTripPlanner when building the road part of the routing graph. Way property sets OSM tags have different meanings in different countries, and how the roads in a particular country or region are tagged affects routing. As an example are roads tagged with `highway=trunk (mainly) walkable in Norway, but forbidden in some other countries. This might lead to OTP being unable to snap stops to these roads, or by giving you poor routing results for walking and biking. You can adjust which road types that are accessible by foot, car & bicycle as well as speed limits, suitability for biking and walking. There are currently 3 wayPropertySets defined; default which is based on California/US mapping standard norway which is adjusted to rules and speeds in Norway uk which is adjusted to rules and speed in the UK To add your own custom property set have a look at org.opentripplanner.graph_builder.module.osm.NorwayWayPropertySet and org.opentripplanner.graph_builder.module.osm.DefaultWayPropertySet . If you choose to mainly rely on the default rules, make sure you add your own rules first before applying the default ones. The mechanism is that for any two identical tags, OTP will use the first one. // build-config.json { osmWayProper t ySe t : \"norway\" } Custom naming You can define a custom naming scheme for elements drawn from OSM by defining an osmNaming field in build-config.json , such as: // build-config.json { \"osmNaming\" : \"portland\" } There is currently only one custom naming module called portland (which has no parameters). Runtime router configuration This section covers all options that can be set for each router using the router-config.json file. These options can be applied by the OTP server without rebuilding the graph. config key description value type value default notes routingDefaults Default routing parameters, which will be applied to every request object see routing defaults timeout maximum time limit for route queries double null units: seconds; see timeouts timeouts when returning multiple itineraries, set different maximum time limits for the 1st, 2nd, etc. itinerary array of doubles [5, 4, 2] units: seconds; see timeouts requestLogFile Path to a plain-text file where requests will be logged string null see logging incoming requests boardTimes change boarding times by mode object null see boarding and alighting times alightTimes change alighting times by mode object null see boarding and alighting times updaters configure real-time updaters, such as GTFS-realtime feeds object null see configuring real-time updaters Routing defaults There are many trip planning options used in the OTP web API, and more exist internally that are not exposed via the API. You may want to change the default value for some of these parameters, i.e. the value which will be applied unless it is overridden in a web API request. A full list of them can be found in the RoutingRequest class in the Javadoc . Any public field or setter method in this class can be given a default value using the routingDefaults section of router-config.json as follows: { \"routingDefaults\" : { \"walkSpeed\" : 2.0 , \"stairsReluctance\" : 4.0 , \"carDropoffTime\" : 240 } } Routing modes The routing request parameter mode determines which transport modalities should be considered when calculating the list of routes. Some modes (mostly bicycle and car) also have optional qualifiers RENT and PARK to specify if vehicles are to be parked at a station or rented. In theory this can also apply to other modes but makes sense only in select cases which are listed below. Whether a transport mode is available highly depends on the input feeds (GTFS, OSM, bike sharing feeds) and the graph building options supplied to OTP. The complete list of modes are: WALK : Walking some or all of the route. TRANSIT : General catch-all for all public transport modes. BICYCLE : Cycling for the entirety of the route or taking a bicycle onto the public transport and cycling from the arrival station to the destination. BICYCLE_RENT : Taking a rented, shared-mobility bike for part or the entirety of the route. Prerequisite: Vehicle positions need to be added to OTP either as static stations or dynamic data feeds. For dynamic bike positions configure an input feed. See Configuring real-time updaters . For static stations check the graph building documentation for the property staticBikeRental . BICYCLE_PARK : Leaving the bicycle at the departure station and walking from the arrival station to the destination. This mode needs to be combined with at least one transit mode (or TRANSIT ) otherwise it behaves like an ordinary bicycle journey. Prerequisite: Bicycle parking stations present in the OSM file and visible to OTP by enabling the property staticBikeParkAndRide during graph build. CAR : Driving your own car the entirety of the route. If this is combined with TRANSIT it will return routes with a Kiss & Ride component. This means that the car is not parked in a permanent parking area but rather the passenger is dropped off (for example, at an airport) and the driver continues driving the car away from the drop off location. CAR_PARK : Driving a car to the park-and-ride facilities near a station and taking public transport. This mode needs to be combined with at least one transit mode (or TRANSIT ) otherwise it behaves like an ordinary car journey. Prerequisite: Park-and-ride areas near the station need to be present in the OSM input file. The following modes are 1-to-1 mappings from the GTFS route_type : TRAM : Tram, streetcar, or light rail. Used for any light rail or street-level system within a metropolitan area. SUBWAY : Subway or metro. Used for any underground rail system within a metropolitan area. RAIL : Used for intercity or long-distance travel. BUS : Used for short- and long-distance bus routes. FERRY : Ferry. Used for short- and long-distance boat service. CABLE_CAR : Cable car. Used for street-level cable cars where the cable runs beneath the car. GONDOLA : Gondola or suspended cable car. Typically used for aerial cable cars where the car is suspended from the cable. FUNICULAR : Funicular. Used for any rail system that moves on steep inclines with a cable traction system. Lastly, this mode is part of the Extended GTFS route types : AIRPLANE : Taking an airplane. Note that there are conceptual overlaps between TRAM , SUBWAY and RAIL and some transport providers categorize their routes differently to others. In other words, what is considered a SUBWAY in one city might be of type RAIL in another. Study your input GTFS feed carefully to find out the appropriate mapping in your region. Drive-to-transit routing defaults When using the \"park and ride\" or \"kiss and ride\" modes (drive to transit), the initial driving time to reach a transit stop or park and ride facility is constrained. You can set a drive time limit in seconds by adding a line like maxPreTransitTime = 1200 to the routingDefaults section. If the limit is too high on a very large street graph, routing performance may suffer. Boarding and alighting times Sometimes there is a need to configure a longer boarding or alighting times for specific modes, such as airplanes or ferries, where the check-in process needs to be done in good time before boarding. The boarding time is added to the time when going from the stop (offboard) vertex to the onboard vertex, and the alight time is added vice versa. The times are configured as seconds needed for the boarding and alighting processes in router-config.json as follows: { \"boardTimes\" : { \"AIRPLANE\" : 2700 }, \"alightTimes\" : { \"AIRPLANE\" : 1200 } } Timeouts Path searches can sometimes take a long time to complete, especially certain problematic cases that have yet to be optimized. Often a first itinerary is found quickly, but it is time-consuming or impossible to find subsequent alternative itineraries and this delays the response. You can set timeouts to avoid tying up server resources on pointless searches and ensure that your users receive a timely response. When a search times out, a WARN level log entry is made with information that can help identify problematic searches and improve our routing methods. The simplest timeout option is: // router-config.json { \"timeout\" : 5.5 } This specifies a single timeout in (optionally fractional) seconds. Searching is aborted after this many seconds and any paths already found are returned to the client. This is equivalent to specifying a timeouts array with a single element. The alternative is: // router-config.json { \"timeouts\" : [ 5 , 4 , 3 , 1 ] } Here, the configuration key is timeouts (plural) and we specify an array of times in floating-point seconds. The Nth element in the array applies to the Nth itinerary search, and importantly all values are relative to the beginning of the search for the first itinerary. If OTP is configured to find more itineraries than there are elements in the timeouts array, the final element in the timeouts array will apply to all remaining unmatched searches. This allows you to keep overall response time down while ensuring that the end user will get at least one response, providing more only when it won't hurt response time. The timeout values will typically be decreasing to reflect the decreasing marginal value of alternative itineraries: everyone wants at least one response, it's nice to have two for comparison, but we only care about having three, four, or more options if completing those extra searches doesn't cause annoyingly long response times. Logging incoming requests You can log some characteristics of trip planning requests in a file for later analysis. Some transit agencies and operators find this information useful for identifying existing or unmet transportation demand. Logging will be performed only if you specify a log file name in the router config: // router-config.json { \"requestLogFile\" : \"/var/otp/request.log\" } Each line in the resulting log file will look like this: 2016-04-19T18:23:13.486 0:0:0:0:0:0:0:1 ARRIVE 2016-04-07T00:17 WALK,BUS,CABLE_CAR,TRANSIT,BUSISH 45.559737193889966 -122.64999389648438 45.525592487765635 -122.39044189453124 6095 3 5864 3 6215 3 The fields are separated by whitespace and are (in order): Date and time the request was received IP address of the user Arrive or depart search The arrival or departure time A comma-separated list of all transport modes selected Origin latitude and longitude Destination latitude and longitude Finally, for each itinerary returned to the user, there is a travel duration in seconds and the number of transit vehicles used in that itinerary. Real-time data GTFS feeds contain schedule data that is is published by an agency or operator in advance. The feed does not account for unexpected service changes or traffic disruptions that occur from day to day. Thus, this kind of data is also referred to as 'static' data or 'theoretical' arrival and departure times. GTFS-Realtime The GTFS-RT spec complements GTFS with three additional kinds of feeds. In contrast to the base GTFS schedule feed, they provide real-time updates ( 'dynamic' data) and are are updated from minute to minute. Alerts are text messages attached to GTFS objects, informing riders of disruptions and changes. TripUpdates report on the status of scheduled trips as they happen, providing observed and predicted arrival and departure times for the remainder of the trip. VehiclePositions give the location of some or all vehicles currently in service, in terms of geographic coordinates or position relative to their scheduled stops. Bicycle rental systems Besides GTFS-RT transit data, OTP can also fetch real-time data about bicycle rental networks including the number of bikes and free parking spaces at each station. We support bike rental systems from JCDecaux, BCycle, VCub, Keolis, Bixi, the Dutch OVFiets system, ShareBike, GBFS and a generic KML format. It is straightforward to extend OTP to support any bike rental system that exposes a JSON API or provides KML place markers, though it requires writing a little code. The generic KML needs to be in format like <?xml version=\"1.0\" encoding=\"utf-8\" ?> <kml xmlns= \"http://www.opengis.net/kml/2.2\" > <Document id= \"root_doc\" > <Schema name= \"citybikes\" id= \"citybikes\" > <SimpleField name= \"ID\" type= \"int\" ></SimpleField> </Schema> <Placemark> <name> A Bike Station </name> <ExtendedData><SchemaData schemaUrl= \"#citybikes\" > <SimpleData name= \"ID\" > 0 </SimpleData> </SchemaData></ExtendedData> <Point><coordinates> 24.950682884886643,60.155923430488102 </coordinates></Point> </Placemark> </Document></kml> Configuring real-time updaters Real-time data can be provided using either a pull or push system. In a pull configuration, the GTFS-RT consumer polls the real-time provider over HTTP. That is to say, OTP fetches a file from a web server every few minutes. In the push configuration, the consumer opens a persistent connection to the GTFS-RT provider, which then sends incremental updates immediately as they become available. OTP can use both approaches. The OneBusAway GTFS-realtime exporter project provides this kind of streaming, incremental updates over a websocket rather than a single large file. Real-time data sources are configured in router-config.json . The updaters section is an array of JSON objects, each of which has a type field and other configuration fields specific to that type. Common to all updater entries that connect to a network resource is the url field. // router-config.json { // Routing defaults are any public field or setter in the Java class // org.opentripplanner.routing.core.RoutingRequest \"routingDefaults\" : { \"numItineraries\" : 6 , \"walkSpeed\" : 2.0 , \"stairsReluctance\" : 4.0 , \"carDropoffTime\" : 240 }, \"updaters\" : [ // GTFS-RT service alerts (frequent polling) { \"type\" : \"real-time-alerts\" , \"frequencySec\" : 30 , \"url\" : \"http://developer.trimet.org/ws/V1/FeedSpecAlerts/appID/0123456789ABCDEF\" , \"feedId\" : \"TriMet\" }, // Polling bike rental updater. // sourceType can be: jcdecaux, b-cycle, bixi, keolis-rennes, ov-fiets, // city-bikes, citi-bike-nyc, next-bike, vcub, kml { \"type\" : \"bike-rental\" , \"frequencySec\" : 300 , \"sourceType\" : \"city-bikes\" , \"url\" : \"http://host.domain.tld\" }, //<!--- San Francisco Bay Area bike share --> { \"type\" : \"bike-rental\" , \"frequencySec\" : 300 , \"sourceType\" : \"sf-bay-area\" , \"url\" : \"http://www.bayareabikeshare.com/stations/json\" }, //<!--- Tampa Area bike share --> { \"type\" : \"bike-rental\" , \"frequencySec\" : 300 , \"sourceType\" : \"gbfs\" , \"url\" : \"http://coast.socialbicycles.com/opendata/\" }, // Polling bike rental updater for DC bikeshare (a Bixi system) // Negative update frequency means to run once and then stop updating (essentially static data) { \"type\" : \"bike-rental\" , \"sourceType\" : \"bixi\" , \"url\" : \"https://www.capitalbikeshare.com/data/stations/bikeStations.xml\" , \"frequencySec\" : -1 }, // Bike parking availability { \"type\" : \"bike-park\" }, // Polling for GTFS-RT TripUpdates) { \"type\" : \"stop-time-updater\" , \"frequencySec\" : 60 , // this is either http or file... shouldn't it default to http or guess from the presence of a URL? \"sourceType\" : \"gtfs-http\" , \"url\" : \"http://developer.trimet.org/ws/V1/TripUpdate/appID/0123456789ABCDEF\" , \"feedId\" : \"TriMet\" }, // Streaming differential GTFS-RT TripUpdates over websockets { \"type\" : \"websocket-gtfs-rt-updater\" } ] } GBFS Configuration Steps to add a GBFS feed to a router: Add one entry in the updater field of router-config.json in the format { \"type\" : \"bike-rental\" , \"frequencySec\" : 60 , \"sourceType\" : \"gbfs\" , \"url\" : \"http://coast.socialbicycles.com/opendata/\" } Follow these instructions to fill these fields: type: \"bike-rental\" frequencySec: frequency in seconds in which the GBFS service will be polled sourceType: \"gbfs\" url: the URL of the GBFS feed (do not include the gbfs.json at the end) * * For a list of known GBFS feeds see the list of known GBFS feeds Configure using command-line arguments Certain settings can be provided on the command line, when starting OpenTripPlanner. See the CommandLineParameters class for a full list of arguments .","title":"Configuration"},{"location":"Configuration/#configuring-opentripplanner","text":"","title":"Configuring OpenTripPlanner"},{"location":"Configuration/#base-directory","text":"The OTP base directory defaults to /var/otp . Unless you tell OTP otherwise, all other configuration, input files and storage directories will be sought immediately beneath this one. This prefix follows UNIX conventions so it should work in Linux and Mac OSX environments, but it is inappropriate in Windows and where the user running OTP either cannot obtain permissions to /var or simply wishes to experiment within his or her home directory rather than deploy a system-wide server. In these cases one should use the basePath switch when starting up OTP to override the default. For example: --basePath /home/username/otp on a Linux system, --basePath /Users/username/otp in Mac OSX, or --basePath C:\\Users\\username\\otp in Windows.","title":"Base directory"},{"location":"Configuration/#routers","text":"A single OTP instance can handle several regions independently. Each of these separate (but potentially geographically overlapping) services is called a router and is referred to by a short unique ID such as 'newyork' or 'paris'. Each router has its own subdirectory in a directory called 'graphs' directly under the OTP base directory, and each router's directory is always named after its router ID. Thus, by default the files for the router 'tokyo' will be located at /var/otp/graphs/tokyo . Here is an example directory layout for an OTP instance with two routers, one for New York City and one for Portland, Oregon: /var/otp \u251c\u2500\u2500 cache \u2502 \u2514\u2500\u2500 ned \u2514\u2500\u2500 graphs \u251c\u2500\u2500 nyc \u2502 \u251c\u2500\u2500 build-config.json \u2502 \u251c\u2500\u2500 Graph.obj \u2502 \u251c\u2500\u2500 long-island-rail-road_20140216_0114.zip \u2502 \u251c\u2500\u2500 mta-new-york-city-transit_20130212_0419.zip \u2502 \u251c\u2500\u2500 new-york-city.osm.pbf \u2502 \u2514\u2500\u2500 port-authority-of-new-york-new-jersey_20150217_0111.zip \u2514\u2500\u2500 pdx \u251c\u2500\u2500 build-config.json \u251c\u2500\u2500 Graph.obj \u251c\u2500\u2500 gtfs.zip \u251c\u2500\u2500 portland_oregon.osm.pbf \u2514\u2500\u2500 router-config.json You can see that each of these subdirectories contains one or more GTFS feeds (which are just zip files full of comma-separated tables), a PBF street map file, some JSON configuration files, and another file called Graph.obj . On startup, OTP scans router directories for input and configuration files, and can optionally store the resulting combined representation of the transportation network as Graph.obj in the same directory to avoid re-processing the data the next time it starts up. The cache directory is where OTP will store its local copies of resources fetched from the internet, such as US elevation tiles.","title":"Routers"},{"location":"Configuration/#system-wide-vs-graph-build-vs-router-configuration","text":"OTP is configured via JSON files. The file otp-config.json is placed in the OTP base directory and contains settings that affect the entire OTP instance. Each router within that instance is configured using two other JSON files placed alongside the input files (OSM, GTFS, elevation data etc.) in the router's directory. These router-level config files are named build-config.json and router-config.json . Each configuration option within each of these files is optional, as are all three of the files themselves. If any option or an entire file is missing, reasonable defaults will be applied. Some parts of the process that loads the street and transit network description are time consuming and memory-hungry. To avoid repeating these slow steps every time OTP starts up, we can trigger them manually whenever the input files change, saving the resulting transportation network description to disk. We call this prepared product a graph (following mathematical terminology ), and refer to these \"heavier\" steps as graph building . They are controlled by build-config.json . There are many other details of OTP operation that can be modified without requiring the potentially long operation of rebuilding the graph. These run-time configuration options are found in router-config.json .","title":"System-wide vs. graph build vs. router configuration"},{"location":"Configuration/#graph-build-configuration","text":"This table lists the possible settings that can be defined in a build-config.json file. Sections follow that describe particular settings in more depth. config key description value type value default notes htmlAnnotations Generate nice HTML report of Graph errors/warnings (annotations) boolean false transit Include all transit input files (GTFS) from scanned directory boolean true useTransfersTxt Create direct transfer edges from transfers.txt in GTFS, instead of based on distance boolean false parentStopLinking Link GTFS stops to their parent stops boolean false stationTransfers Create direct transfers between the constituent stops of each parent station boolean false stopClusterMode Stop clusters can be built in one of two ways, either by geographical proximity and name, or according to a parent/child station topology, if it exists enum proximity options: proximity , parentStation subwayAccessTime Minutes necessary to reach stops served by trips on routes of route_type=1 (subway) from the street double 2.0 units: minutes streets Include street input files (OSM/PBF) boolean true embedRouterConfig Embed the Router config in the graph, which allows it to be sent to a server fully configured over the wire boolean true areaVisibility Perform visibility calculations. If this is true OTP attempts to calculate a path straight through an OSM area using the shortest way rather than around the edge of it. (These calculations can be time consuming). boolean false platformEntriesLinking Link unconnected entries to public transport platforms boolean false matchBusRoutesToStreets Based on GTFS shape data, guess which OSM streets each bus runs on to improve stop linking boolean false fetchElevationUS Download US NED elevation data and apply it to the graph boolean false elevationBucket If specified, download NED elevation tiles from the given AWS S3 bucket object null provide an object with accessKey , secretKey , and bucketName for AWS S3 elevationUnitMultiplier Specify a multiplier to convert elevation units from source to meters double 1.0 see Elevation unit conversion readCachedElevations If true, reads in pre-calculated elevation data. boolean true see Elevation Data Calculation Optimizations writeCachedElevations If true, writes the calculated elevation data. boolean false see Elevation Data Calculation Optimizations multiThreadElevationCalculations If true, the elevation module will use multi-threading during elevation calculations. boolean false see Elevation Data Calculation Optimizations fares A specific fares service to use object null see fares configuration osmNaming A custom OSM namer to use object null see custom naming osmWayPropertySet Custom OSM way properties string default options: default , norway , uk staticBikeRental Whether bike rental stations should be loaded from OSM, rather than periodically dynamically pulled from APIs boolean false staticParkAndRide Whether we should create car P+R stations from OSM data boolean true staticBikeParkAndRide Whether we should create bike P+R stations from OSM data boolean false maxHtmlAnnotationsPerFile If number of annotations is larger then specified number annotations will be split in multiple files int 1,000 maxInterlineDistance Maximal distance between stops in meters that will connect consecutive trips that are made with same vehicle int 200 units: meters islandWithoutStopsMaxSize Pruning threshold for islands without stops. Any such island under this size will be pruned int 40 islandWithStopsMaxSize Pruning threshold for islands with stops. Any such island under this size will be pruned int 5 banDiscouragedWalking should walking should be allowed on OSM ways tagged with foot=discouraged\" boolean false banDiscouragedBiking should walking should be allowed on OSM ways tagged with bicycle=discouraged\" boolean false maxTransferDistance Transfers up to this length in meters will be pre-calculated and included in the Graph double 2,000 units: meters extraEdgesStopPlatformLink add extra edges when linking a stop to a platform, to prevent detours along the platform edge boolean false This list of parameters in defined in the code for GraphBuilderParameters .","title":"Graph build configuration"},{"location":"Configuration/#reaching-a-subway-platform","text":"The boarding locations for some modes of transport such as subways and airplanes can be slow to reach from the street. When planning a trip, we need to allow additional time to reach these locations to properly inform the passenger. For example, this helps avoid suggesting short bus rides between two subway rides as a way to improve travel time. You can specify how long it takes to reach a subway platform // build-config.json { \"subwayAccessTime\" : 2.5 } Stops in GTFS do not necessarily serve a single transit mode, but in practice this is usually the case. This additional access time will be added to any stop that is visited by trips on subway routes (GTFS route_type = 1). This setting does not generalize well to airplanes because you often need much longer to check in to a flight (2-3 hours for international flights) than to alight and exit the airport (perhaps 1 hour). Therefore there is currently no per-mode access time, it is subway-specific.","title":"Reaching a subway platform"},{"location":"Configuration/#transferring-within-stations","text":"Subway systems tend to exist in their own layer of the city separate from the surface, though there are exceptions where tracks lie right below the street and transfers happen via the surface. In systems where the subway is quite deep and transfers happen via tunnels, the time required for an in-station transfer is often less than that for a surface transfer. A proposal was made to provide detailed station pathways in GTFS but it is not in common use. One way to resolve this problem is by ensuring that the GTFS feed codes each platform as a separate stop, then micro-mapping stations in OSM. When OSM data contains a detailed description of walkways, stairs, and platforms within a station, GTFS stops can be linked to the nearest platform and transfers will happen via the OSM ways, which should yield very realistic transfer time expectations. This works particularly well in above-ground train stations where the layering of non-intersecting ways is less prevalent. Here's an example in the Netherlands: View Larger Map When such micro-mapping data is not available, we need to rely on information from GTFS including how stops are grouped into stations and a table of transfer timings where available. During the graph build, OTP can create preferential connections between each pair of stops in the same station to favor in-station transfers: // build-config.json { \"stationTransfers\" : true } Note that this method is at odds with micro-mapping and might make some transfers artificially short.","title":"Transferring within stations"},{"location":"Configuration/#elevation-data","text":"OpenTripPlanner can \"drape\" the OSM street network over a digital elevation model (DEM). This allows OTP to draw an elevation profile for the on-street portion of itineraries, and helps provide better routing for bicyclists. It even helps avoid hills for walking itineraries. DEMs are usually supplied as rasters (regular grids of numbers) stored in image formats such as GeoTIFF.","title":"Elevation data"},{"location":"Configuration/#us-national-elevation-dataset","text":"In the United States, a high resolution National Elevation Dataset is available for the entire territory. The US Geological Survey (USGS) delivers this dataset in tiles via a somewhat awkward heavyweight web-based GIS which generates and emails you download links. OpenTripPlanner contains a module which will automatically contact this service and download the proper tiles to completely cover your transit and street network area. This process is rather slow (download is around 1.5 hours, then setting elevation for streets takes about 5 minutes for the Portland, Oregon region), but once the tiles are downloaded OTP will keep them in local cache for the next graph build operation. To auto-download NED tiles when building your graph, add the following line to build-config.json in your router directory: // build-config.json { \"fetchElevationUS\" : true } You may also want to add the --cache <directory> command line parameter to specify a custom NED tile cache location. NED downloads take quite a long time and slow down the graph building process. The USGS will also deliver the whole dataset in bulk if you send them a hard drive . OpenTripPlanner contains another module that will then automatically fetch data in this format from an Amazon S3 copy of your bulk data. You can configure it as follows in build-config.json : { \"elevationBucket\" : { \"accessKey\" : \"your-aws-access-key\" , \"secretKey\" : \"corresponding-aws-secret-key\" , \"bucketName\" : \"ned13\" } }","title":"U.S. National Elevation Dataset"},{"location":"Configuration/#geoid-difference","text":"With some elevation data, the elevation values are specified as relative to the a geoid (irregular estimate of mean sea level). See issue #2301 for detailed discussion of this. In these cases, it is necessary to also add this geoid value onto the elevation value to get the correct result. OTP can automatically calculate these values in one of two ways. The first way is to use the geoid difference value that is calculated once at the center of the graph. This value is returned in each trip plan response in the ElevationMetadata field. Using a single value can be sufficient for smaller OTP deployments, but might result in incorrect values at the edges of larger OTP deployments. If your OTP instance uses this, it is recommended to set a default request value in the router-config.json file as follows: // router-config.json { \"routingDefaults\" : { \"geoidElevation \" : true } } The second way is to precompute these geoid difference values at a more granular level and include them when calculating elevations for each sampled point along each street edge. In order to speed up calculations, the geoid difference values are calculated and cached using only 2 significant digits of GPS coordinates. This is more than enough detail for most regions of the world and should result in less than one meter of difference in areas that have large changes in geoid difference values. To enable this, include the following in the build-config.json file: // build-config.json { \"includeEllipsoidToGeoidDifference\" : true } If the geoid difference values are precomputed, be careful to not set the routing resource value of geoidElevation to true in order to avoid having the graph-wide geoid added again to all elevation values in the relevant street edges in responses.","title":"Geoid Difference"},{"location":"Configuration/#other-raster-elevation-data","text":"For other parts of the world you will need a GeoTIFF file containing the elevation data. These are often available from national geographic surveys, or you can always fall back on the worldwide Space Shuttle Radar Topography Mission (SRTM) data. This not particularly high resolution (roughly 30 meters horizontally) but it can give acceptable results. Simply place the elevation data file in the directory with the other graph builder inputs, alongside the GTFS and OSM data. Make sure the file has a .tiff or .tif extension, and the graph builder should detect its presence and apply the elevation data to the streets. OTP should automatically handle DEM GeoTIFFs in most common projections. You may want to check for elevation-related error messages during the graph build process to make sure OTP has properly discovered the projection. If you are using a DEM in unprojected coordinates make sure that the axis order is (longitude, latitude) rather than (latitude, longitude). Unfortunately there is no reliable standard for WGS84 axis order, so OTP uses the same axis order as the above-mentioned SRTM data, which is also the default for the popular Proj4 library. DEM files(USGS DEM) is not supported by OTP, but can be converted to GeoTIFF with tools like GDAL . Use gdal_merge.py -o merged.tiff *.dem to merge a set of dem files into one tif file. See Interline PlanetUtils for a set of scripts to download, merge, and resample Mapzen/Amazon Terrain Tiles .","title":"Other raster elevation data"},{"location":"Configuration/#elevation-unit-conversion","text":"By default, OTP expects the elevation data to use metres. However, by setting elevationUnitMultiplier in build-config.json , it is possible to define a multiplier that converts the elevation values from some other unit to metres. // build-config.json { // Correct conversation multiplier when source data uses decimetres instead of metres \"elevationUnitMultiplier\" : 0.1 }","title":"Elevation unit conversion"},{"location":"Configuration/#elevation-data-calculation-optimizations","text":"Calculating elevations on all StreetEdges can take a dramatically long time. In a very large graph build for multiple Northeast US states, the time it took to download the elevation data and calculate all of the elevations took 5,509 seconds (roughly 1.5 hours). If you are using cloud computing for your OTP instances, it is recommended to create prebuilt images that contain the elevation data you need. This will save time because all of the data won't need to be downloaded. However, the bulk of the time will still be spent calculating elevations for all of the street edges. Therefore, a further optimization can be done to calculate and save the elevation data during a graph build and then save it for future use.","title":"Elevation Data Calculation Optimizations"},{"location":"Configuration/#reusing-elevation-data-from-previous-builds","text":"In order to write out the precalculated elevation data, add this to your build-config.json file: // build-config.json { \"writeCachedElevations\" : true } After building the graph, a file called cached_elevations.obj will be written to the cache directory. By default, this file is not written during graph builds. There is also a graph build parameter called readCachedElevations which is set to true by default. In graph builds, the elevation module will attempt to read the cached_elevations.obj file from the cache directory. The cache directory defaults to /var/otp/cache , but this can be overriden via the CLI argument --cache <directory> . For the same graph build for multiple Northeast US states, the time it took with using this predownloaded and precalculated data became 543.7 seconds (roughly 9 minutes). The cached data is a lookup table where the coordinate sequences of respective street edges are used as keys for calculated data. It is assumed that all of the other input data except for the OpenStreetMap data remains the same between graph builds. Therefore, if the underlying elevation data is changed, or different configuration values for elevationUnitMultiplier or includeEllipsoidToGeoidDifference are used, then this data becomes invalid and all elevation data should be recalculated. Over time, various edits to OpenStreetMap will cause this cached data to become stale and not include new OSM ways. Therefore, periodic update of this cached data is recommended.","title":"Reusing elevation data from previous builds"},{"location":"Configuration/#configuring-multi-threading-during-elevation-calculations","text":"For unknown reasons that seem to depend on data and machine settings, it might be faster to use a single processor. For this reason, multi-threading of elevation calculations is only done if multiThreadElevationCalculations is set to true. To enable multi-threading in the elevation module, add the following to the build-config.json file: // build-config.json { \"multiThreadElevationCalculations\" : true }","title":"Configuring multi-threading during elevation calculations"},{"location":"Configuration/#fares-configuration","text":"By default OTP will compute fares according to the GTFS specification if fare data is provided in your GTFS input. For more complex scenarios or to handle bike rental fares, it is necessary to manually configure fares using the fares section in build-config.json . You can combine different fares (for example transit and bike-rental) by defining a combinationStrategy parameter, and a list of sub-fares to combine (all fields starting with fare are considered to be sub-fares). // build-config.json { // Select the custom fare \"seattle\" \"fares\" : \"seattle\" , // OR this alternative form that could allow additional configuration \"fares\" : { \"type\" : \"seattle\" } } // build-config.json { \"fares\" : { // Combine two fares by simply adding them \"combinationStrategy\" : \"additive\" , // First fare to combine \"fare0\" : \"new-york\" , // Second fare to combine \"fare1\" : { \"type\" : \"bike-rental-time-based\" , \"currency\" : \"USD\" , \"prices\" : { // For trip shorter than 30', $4 fare \"30\" : 4.00 , // For trip shorter than 1h, $6 fare \"1:00\" : 6.00 } } // We could also add fareFoo, fareBar... } } The current list of custom fare type is: bike-rental-time-based - accepting the following parameters: currency - the ISO 4217 currency code to use, such as \"EUR\" or \"USD\" , prices - a list of {time, price}. The resulting cost is the smallest cost where the elapsed time of bike rental is lower than the defined time. san-francisco (no parameters) new-york (no parameters) seattle (no parameters) The current list of combinationStrategy is: additive - simply adds all sub-fares.","title":"Fares configuration"},{"location":"Configuration/#osm-openstreetmap-configuration","text":"It is possible to adjust how OSM data is interpreted by OpenTripPlanner when building the road part of the routing graph.","title":"OSM / OpenStreetMap configuration"},{"location":"Configuration/#way-property-sets","text":"OSM tags have different meanings in different countries, and how the roads in a particular country or region are tagged affects routing. As an example are roads tagged with `highway=trunk (mainly) walkable in Norway, but forbidden in some other countries. This might lead to OTP being unable to snap stops to these roads, or by giving you poor routing results for walking and biking. You can adjust which road types that are accessible by foot, car & bicycle as well as speed limits, suitability for biking and walking. There are currently 3 wayPropertySets defined; default which is based on California/US mapping standard norway which is adjusted to rules and speeds in Norway uk which is adjusted to rules and speed in the UK To add your own custom property set have a look at org.opentripplanner.graph_builder.module.osm.NorwayWayPropertySet and org.opentripplanner.graph_builder.module.osm.DefaultWayPropertySet . If you choose to mainly rely on the default rules, make sure you add your own rules first before applying the default ones. The mechanism is that for any two identical tags, OTP will use the first one. // build-config.json { osmWayProper t ySe t : \"norway\" }","title":"Way property sets"},{"location":"Configuration/#custom-naming","text":"You can define a custom naming scheme for elements drawn from OSM by defining an osmNaming field in build-config.json , such as: // build-config.json { \"osmNaming\" : \"portland\" } There is currently only one custom naming module called portland (which has no parameters).","title":"Custom naming"},{"location":"Configuration/#runtime-router-configuration","text":"This section covers all options that can be set for each router using the router-config.json file. These options can be applied by the OTP server without rebuilding the graph. config key description value type value default notes routingDefaults Default routing parameters, which will be applied to every request object see routing defaults timeout maximum time limit for route queries double null units: seconds; see timeouts timeouts when returning multiple itineraries, set different maximum time limits for the 1st, 2nd, etc. itinerary array of doubles [5, 4, 2] units: seconds; see timeouts requestLogFile Path to a plain-text file where requests will be logged string null see logging incoming requests boardTimes change boarding times by mode object null see boarding and alighting times alightTimes change alighting times by mode object null see boarding and alighting times updaters configure real-time updaters, such as GTFS-realtime feeds object null see configuring real-time updaters","title":"Runtime router configuration"},{"location":"Configuration/#routing-defaults","text":"There are many trip planning options used in the OTP web API, and more exist internally that are not exposed via the API. You may want to change the default value for some of these parameters, i.e. the value which will be applied unless it is overridden in a web API request. A full list of them can be found in the RoutingRequest class in the Javadoc . Any public field or setter method in this class can be given a default value using the routingDefaults section of router-config.json as follows: { \"routingDefaults\" : { \"walkSpeed\" : 2.0 , \"stairsReluctance\" : 4.0 , \"carDropoffTime\" : 240 } }","title":"Routing defaults"},{"location":"Configuration/#routing-modes","text":"The routing request parameter mode determines which transport modalities should be considered when calculating the list of routes. Some modes (mostly bicycle and car) also have optional qualifiers RENT and PARK to specify if vehicles are to be parked at a station or rented. In theory this can also apply to other modes but makes sense only in select cases which are listed below. Whether a transport mode is available highly depends on the input feeds (GTFS, OSM, bike sharing feeds) and the graph building options supplied to OTP. The complete list of modes are: WALK : Walking some or all of the route. TRANSIT : General catch-all for all public transport modes. BICYCLE : Cycling for the entirety of the route or taking a bicycle onto the public transport and cycling from the arrival station to the destination. BICYCLE_RENT : Taking a rented, shared-mobility bike for part or the entirety of the route. Prerequisite: Vehicle positions need to be added to OTP either as static stations or dynamic data feeds. For dynamic bike positions configure an input feed. See Configuring real-time updaters . For static stations check the graph building documentation for the property staticBikeRental . BICYCLE_PARK : Leaving the bicycle at the departure station and walking from the arrival station to the destination. This mode needs to be combined with at least one transit mode (or TRANSIT ) otherwise it behaves like an ordinary bicycle journey. Prerequisite: Bicycle parking stations present in the OSM file and visible to OTP by enabling the property staticBikeParkAndRide during graph build. CAR : Driving your own car the entirety of the route. If this is combined with TRANSIT it will return routes with a Kiss & Ride component. This means that the car is not parked in a permanent parking area but rather the passenger is dropped off (for example, at an airport) and the driver continues driving the car away from the drop off location. CAR_PARK : Driving a car to the park-and-ride facilities near a station and taking public transport. This mode needs to be combined with at least one transit mode (or TRANSIT ) otherwise it behaves like an ordinary car journey. Prerequisite: Park-and-ride areas near the station need to be present in the OSM input file. The following modes are 1-to-1 mappings from the GTFS route_type : TRAM : Tram, streetcar, or light rail. Used for any light rail or street-level system within a metropolitan area. SUBWAY : Subway or metro. Used for any underground rail system within a metropolitan area. RAIL : Used for intercity or long-distance travel. BUS : Used for short- and long-distance bus routes. FERRY : Ferry. Used for short- and long-distance boat service. CABLE_CAR : Cable car. Used for street-level cable cars where the cable runs beneath the car. GONDOLA : Gondola or suspended cable car. Typically used for aerial cable cars where the car is suspended from the cable. FUNICULAR : Funicular. Used for any rail system that moves on steep inclines with a cable traction system. Lastly, this mode is part of the Extended GTFS route types : AIRPLANE : Taking an airplane. Note that there are conceptual overlaps between TRAM , SUBWAY and RAIL and some transport providers categorize their routes differently to others. In other words, what is considered a SUBWAY in one city might be of type RAIL in another. Study your input GTFS feed carefully to find out the appropriate mapping in your region.","title":"Routing modes"},{"location":"Configuration/#drive-to-transit-routing-defaults","text":"When using the \"park and ride\" or \"kiss and ride\" modes (drive to transit), the initial driving time to reach a transit stop or park and ride facility is constrained. You can set a drive time limit in seconds by adding a line like maxPreTransitTime = 1200 to the routingDefaults section. If the limit is too high on a very large street graph, routing performance may suffer.","title":"Drive-to-transit routing defaults"},{"location":"Configuration/#boarding-and-alighting-times","text":"Sometimes there is a need to configure a longer boarding or alighting times for specific modes, such as airplanes or ferries, where the check-in process needs to be done in good time before boarding. The boarding time is added to the time when going from the stop (offboard) vertex to the onboard vertex, and the alight time is added vice versa. The times are configured as seconds needed for the boarding and alighting processes in router-config.json as follows: { \"boardTimes\" : { \"AIRPLANE\" : 2700 }, \"alightTimes\" : { \"AIRPLANE\" : 1200 } }","title":"Boarding and alighting times"},{"location":"Configuration/#timeouts","text":"Path searches can sometimes take a long time to complete, especially certain problematic cases that have yet to be optimized. Often a first itinerary is found quickly, but it is time-consuming or impossible to find subsequent alternative itineraries and this delays the response. You can set timeouts to avoid tying up server resources on pointless searches and ensure that your users receive a timely response. When a search times out, a WARN level log entry is made with information that can help identify problematic searches and improve our routing methods. The simplest timeout option is: // router-config.json { \"timeout\" : 5.5 } This specifies a single timeout in (optionally fractional) seconds. Searching is aborted after this many seconds and any paths already found are returned to the client. This is equivalent to specifying a timeouts array with a single element. The alternative is: // router-config.json { \"timeouts\" : [ 5 , 4 , 3 , 1 ] } Here, the configuration key is timeouts (plural) and we specify an array of times in floating-point seconds. The Nth element in the array applies to the Nth itinerary search, and importantly all values are relative to the beginning of the search for the first itinerary. If OTP is configured to find more itineraries than there are elements in the timeouts array, the final element in the timeouts array will apply to all remaining unmatched searches. This allows you to keep overall response time down while ensuring that the end user will get at least one response, providing more only when it won't hurt response time. The timeout values will typically be decreasing to reflect the decreasing marginal value of alternative itineraries: everyone wants at least one response, it's nice to have two for comparison, but we only care about having three, four, or more options if completing those extra searches doesn't cause annoyingly long response times.","title":"Timeouts"},{"location":"Configuration/#logging-incoming-requests","text":"You can log some characteristics of trip planning requests in a file for later analysis. Some transit agencies and operators find this information useful for identifying existing or unmet transportation demand. Logging will be performed only if you specify a log file name in the router config: // router-config.json { \"requestLogFile\" : \"/var/otp/request.log\" } Each line in the resulting log file will look like this: 2016-04-19T18:23:13.486 0:0:0:0:0:0:0:1 ARRIVE 2016-04-07T00:17 WALK,BUS,CABLE_CAR,TRANSIT,BUSISH 45.559737193889966 -122.64999389648438 45.525592487765635 -122.39044189453124 6095 3 5864 3 6215 3 The fields are separated by whitespace and are (in order): Date and time the request was received IP address of the user Arrive or depart search The arrival or departure time A comma-separated list of all transport modes selected Origin latitude and longitude Destination latitude and longitude Finally, for each itinerary returned to the user, there is a travel duration in seconds and the number of transit vehicles used in that itinerary.","title":"Logging incoming requests"},{"location":"Configuration/#real-time-data","text":"GTFS feeds contain schedule data that is is published by an agency or operator in advance. The feed does not account for unexpected service changes or traffic disruptions that occur from day to day. Thus, this kind of data is also referred to as 'static' data or 'theoretical' arrival and departure times.","title":"Real-time data"},{"location":"Configuration/#gtfs-realtime","text":"The GTFS-RT spec complements GTFS with three additional kinds of feeds. In contrast to the base GTFS schedule feed, they provide real-time updates ( 'dynamic' data) and are are updated from minute to minute. Alerts are text messages attached to GTFS objects, informing riders of disruptions and changes. TripUpdates report on the status of scheduled trips as they happen, providing observed and predicted arrival and departure times for the remainder of the trip. VehiclePositions give the location of some or all vehicles currently in service, in terms of geographic coordinates or position relative to their scheduled stops.","title":"GTFS-Realtime"},{"location":"Configuration/#bicycle-rental-systems","text":"Besides GTFS-RT transit data, OTP can also fetch real-time data about bicycle rental networks including the number of bikes and free parking spaces at each station. We support bike rental systems from JCDecaux, BCycle, VCub, Keolis, Bixi, the Dutch OVFiets system, ShareBike, GBFS and a generic KML format. It is straightforward to extend OTP to support any bike rental system that exposes a JSON API or provides KML place markers, though it requires writing a little code. The generic KML needs to be in format like <?xml version=\"1.0\" encoding=\"utf-8\" ?> <kml xmlns= \"http://www.opengis.net/kml/2.2\" > <Document id= \"root_doc\" > <Schema name= \"citybikes\" id= \"citybikes\" > <SimpleField name= \"ID\" type= \"int\" ></SimpleField> </Schema> <Placemark> <name> A Bike Station </name> <ExtendedData><SchemaData schemaUrl= \"#citybikes\" > <SimpleData name= \"ID\" > 0 </SimpleData> </SchemaData></ExtendedData> <Point><coordinates> 24.950682884886643,60.155923430488102 </coordinates></Point> </Placemark> </Document></kml>","title":"Bicycle rental systems"},{"location":"Configuration/#configuring-real-time-updaters","text":"Real-time data can be provided using either a pull or push system. In a pull configuration, the GTFS-RT consumer polls the real-time provider over HTTP. That is to say, OTP fetches a file from a web server every few minutes. In the push configuration, the consumer opens a persistent connection to the GTFS-RT provider, which then sends incremental updates immediately as they become available. OTP can use both approaches. The OneBusAway GTFS-realtime exporter project provides this kind of streaming, incremental updates over a websocket rather than a single large file. Real-time data sources are configured in router-config.json . The updaters section is an array of JSON objects, each of which has a type field and other configuration fields specific to that type. Common to all updater entries that connect to a network resource is the url field. // router-config.json { // Routing defaults are any public field or setter in the Java class // org.opentripplanner.routing.core.RoutingRequest \"routingDefaults\" : { \"numItineraries\" : 6 , \"walkSpeed\" : 2.0 , \"stairsReluctance\" : 4.0 , \"carDropoffTime\" : 240 }, \"updaters\" : [ // GTFS-RT service alerts (frequent polling) { \"type\" : \"real-time-alerts\" , \"frequencySec\" : 30 , \"url\" : \"http://developer.trimet.org/ws/V1/FeedSpecAlerts/appID/0123456789ABCDEF\" , \"feedId\" : \"TriMet\" }, // Polling bike rental updater. // sourceType can be: jcdecaux, b-cycle, bixi, keolis-rennes, ov-fiets, // city-bikes, citi-bike-nyc, next-bike, vcub, kml { \"type\" : \"bike-rental\" , \"frequencySec\" : 300 , \"sourceType\" : \"city-bikes\" , \"url\" : \"http://host.domain.tld\" }, //<!--- San Francisco Bay Area bike share --> { \"type\" : \"bike-rental\" , \"frequencySec\" : 300 , \"sourceType\" : \"sf-bay-area\" , \"url\" : \"http://www.bayareabikeshare.com/stations/json\" }, //<!--- Tampa Area bike share --> { \"type\" : \"bike-rental\" , \"frequencySec\" : 300 , \"sourceType\" : \"gbfs\" , \"url\" : \"http://coast.socialbicycles.com/opendata/\" }, // Polling bike rental updater for DC bikeshare (a Bixi system) // Negative update frequency means to run once and then stop updating (essentially static data) { \"type\" : \"bike-rental\" , \"sourceType\" : \"bixi\" , \"url\" : \"https://www.capitalbikeshare.com/data/stations/bikeStations.xml\" , \"frequencySec\" : -1 }, // Bike parking availability { \"type\" : \"bike-park\" }, // Polling for GTFS-RT TripUpdates) { \"type\" : \"stop-time-updater\" , \"frequencySec\" : 60 , // this is either http or file... shouldn't it default to http or guess from the presence of a URL? \"sourceType\" : \"gtfs-http\" , \"url\" : \"http://developer.trimet.org/ws/V1/TripUpdate/appID/0123456789ABCDEF\" , \"feedId\" : \"TriMet\" }, // Streaming differential GTFS-RT TripUpdates over websockets { \"type\" : \"websocket-gtfs-rt-updater\" } ] }","title":"Configuring real-time updaters"},{"location":"Configuration/#gbfs-configuration","text":"Steps to add a GBFS feed to a router: Add one entry in the updater field of router-config.json in the format { \"type\" : \"bike-rental\" , \"frequencySec\" : 60 , \"sourceType\" : \"gbfs\" , \"url\" : \"http://coast.socialbicycles.com/opendata/\" } Follow these instructions to fill these fields: type: \"bike-rental\" frequencySec: frequency in seconds in which the GBFS service will be polled sourceType: \"gbfs\" url: the URL of the GBFS feed (do not include the gbfs.json at the end) * * For a list of known GBFS feeds see the list of known GBFS feeds","title":"GBFS Configuration"},{"location":"Configuration/#configure-using-command-line-arguments","text":"Certain settings can be provided on the command line, when starting OpenTripPlanner. See the CommandLineParameters class for a full list of arguments .","title":"Configure using command-line arguments"},{"location":"Deployments/","text":"OpenTripPlanner Deployments Worldwide Official Production The following are known deployments of OTP in a government- or agency-sponsored production capacity: Finland (nationwide) The Helsinki Regional Transport Authority , the Finnish Transport Agency , and other Finnish cities have collaborated to create Digitransit , providing OTP-based trip planners, APIs, open data, Docker containers and open source code. Each member organisation runs its own instance of a shared codebase and deployment environment. Their source code is available on Github , including a new custom UI . This system also has a strong real-time component. Norway (nationwide) Ruter provides a journey planner for the Oslo region . It has been in production since January 2016 and serves around 200,000 users per day. Since November 2017, Entur has also prodvided a nation-wide journey planner which consumes schedule data in the EU standard NeTEx format with SIRI realtime updates. Portland, Oregon TriMet is the agency that originally started the OpenTripPlanner project. Their Regional Trip Planner is based on OTP and provides about 40,000 trip plans on a typical weekday. New York State The State Department of Transportation's transit trip planner provides itineraries for public transit systems throughout the state in a single unified OTP instance. Los Angeles, California The new metro.net trip planner . Atlanta, Georgia The Metropolitan Atlanta Rapid Transit Authority's (MARTA) trip planner and the Atlanta region's transit information hub atltransit.org both use OTP to power their website trip planners. Boston, Massachusetts The Massachusetts Bay Transportation Authority trip planner . Seattle, Washington The Sound Transit Trip Planner is based on OTP. OTP also powers the trip planning feature of the OneBusAway native apps in the Puget Sound region. Technical details are here . Tampa, Florida Hillsoborough Area Regional Transit uses an OpenTripPlanner server to power the trip planning feature of the OneBusAway native apps in their region. Technical details are here . Piemonte Region, Italy and the City of Torino built on OpenTripPlanner by 5T . Valencia, Spain from the Municipal Transport Company of Valencia S.A.U. Grenoble, France from SMTC, Grenoble Alpes m\u00e9tropole, l'\u00c9tat Fran\u00e7ais, the Rh\u00f4ne-alpes region, the Is\u00e8re council and the City of Grenoble. Rennes, France where the STAR network provides an OTP client for iOS , Android , Windows Phone et Web. Alen\u00e7on, France integrated urban and school bus network planner from R\u00e9unir Alen\u00e7on . Pozna\u0144, Poland from Urban Transport Authority of Pozna\u0144 (ZTM Poznan). Trento Province, Italy - ViaggiaTrento and ViaggiaRovereto were implemented as part of the SmartCampus Project , a research project founded by TrentoRise , UNITN , and FBK . University of South Florida (Tampa, Florida). The USF Maps App is a responsive web application for that helps university students, staff, and visitors find their way around the campus using multiple modes of transportation, including the USF Bull Runner campus shuttle, Share-A-Bull bike share, and pedestrian pathways. Open-sourced on Github . Independent Production The following OTP-based services are presented as production-quality deployments, but are not backed by an official transportation authority or government. OTP is also known to be used on the back end of several popular multi-city mobile trip planning applications. The Netherlands (nationwide) Plannerstack Foundation provides national scale trip planning APIs using OTP and other open source trip planners, based on OpenOV's extremely detailed open data including minutely real-time updates for every vehicle in the country. OTP Android by CUTR-USF and Vreixo Gonz\u00e1lez can find itineraries on many different OTP servers via a service discovery mechanism. ViviBus Bologna Bologna, Italy.","title":"Deployments"},{"location":"Deployments/#opentripplanner-deployments-worldwide","text":"","title":"OpenTripPlanner Deployments Worldwide"},{"location":"Deployments/#official-production","text":"The following are known deployments of OTP in a government- or agency-sponsored production capacity: Finland (nationwide) The Helsinki Regional Transport Authority , the Finnish Transport Agency , and other Finnish cities have collaborated to create Digitransit , providing OTP-based trip planners, APIs, open data, Docker containers and open source code. Each member organisation runs its own instance of a shared codebase and deployment environment. Their source code is available on Github , including a new custom UI . This system also has a strong real-time component. Norway (nationwide) Ruter provides a journey planner for the Oslo region . It has been in production since January 2016 and serves around 200,000 users per day. Since November 2017, Entur has also prodvided a nation-wide journey planner which consumes schedule data in the EU standard NeTEx format with SIRI realtime updates. Portland, Oregon TriMet is the agency that originally started the OpenTripPlanner project. Their Regional Trip Planner is based on OTP and provides about 40,000 trip plans on a typical weekday. New York State The State Department of Transportation's transit trip planner provides itineraries for public transit systems throughout the state in a single unified OTP instance. Los Angeles, California The new metro.net trip planner . Atlanta, Georgia The Metropolitan Atlanta Rapid Transit Authority's (MARTA) trip planner and the Atlanta region's transit information hub atltransit.org both use OTP to power their website trip planners. Boston, Massachusetts The Massachusetts Bay Transportation Authority trip planner . Seattle, Washington The Sound Transit Trip Planner is based on OTP. OTP also powers the trip planning feature of the OneBusAway native apps in the Puget Sound region. Technical details are here . Tampa, Florida Hillsoborough Area Regional Transit uses an OpenTripPlanner server to power the trip planning feature of the OneBusAway native apps in their region. Technical details are here . Piemonte Region, Italy and the City of Torino built on OpenTripPlanner by 5T . Valencia, Spain from the Municipal Transport Company of Valencia S.A.U. Grenoble, France from SMTC, Grenoble Alpes m\u00e9tropole, l'\u00c9tat Fran\u00e7ais, the Rh\u00f4ne-alpes region, the Is\u00e8re council and the City of Grenoble. Rennes, France where the STAR network provides an OTP client for iOS , Android , Windows Phone et Web. Alen\u00e7on, France integrated urban and school bus network planner from R\u00e9unir Alen\u00e7on . Pozna\u0144, Poland from Urban Transport Authority of Pozna\u0144 (ZTM Poznan). Trento Province, Italy - ViaggiaTrento and ViaggiaRovereto were implemented as part of the SmartCampus Project , a research project founded by TrentoRise , UNITN , and FBK . University of South Florida (Tampa, Florida). The USF Maps App is a responsive web application for that helps university students, staff, and visitors find their way around the campus using multiple modes of transportation, including the USF Bull Runner campus shuttle, Share-A-Bull bike share, and pedestrian pathways. Open-sourced on Github .","title":"Official Production"},{"location":"Deployments/#independent-production","text":"The following OTP-based services are presented as production-quality deployments, but are not backed by an official transportation authority or government. OTP is also known to be used on the back end of several popular multi-city mobile trip planning applications. The Netherlands (nationwide) Plannerstack Foundation provides national scale trip planning APIs using OTP and other open source trip planners, based on OpenOV's extremely detailed open data including minutely real-time updates for every vehicle in the country. OTP Android by CUTR-USF and Vreixo Gonz\u00e1lez can find itineraries on many different OTP servers via a service discovery mechanism. ViviBus Bologna Bologna, Italy.","title":"Independent Production"},{"location":"Developers-Guide/","text":"Developers Guide Working on OTP in an IDE Most people writing or modifying OTP code use an Integrated Development Environment (IDE). Some of the most popular IDEs for Java development are Eclipse , IntelliJ IDEA , and NetBeans . All three of these environments are good for working on OTP, and any IDE with Maven build support should also work (ensure that you have the Maven plugins installed and enabled). Git integration is a plus since OTP is under Git version control. Many of the Core OTP developers use IntelliJ IDEA. It is an excellent IDE, and in my experience is quicker and more stable than the competition. IntelliJ IDEA is a commercial product, but there is an open source \"community edition\" that is completely sufficient for working on OTP. Rather than using the version control support in my IDE, I usually find it more straightforward to clone the OTP GitHub repository manually (on the command line or using some other Git interface tool), then import the resulting local OTP repository into my IDE as a Maven project. The IDE should then take care of fetching all the libraries OTP depends on, based on the Maven project description (POM file) in the base of the OTP repository. This step can take a long time because it involves downloading a lot of JAR files. When running your local copy of the OTP source within an IDE, all command line switches and configuration options will be identical to the ones used when running the OTP JAR from the command line (as described in the basic introduction and configuration reference ). The only difference is that you need to manually specify the main class. When you run a JAR from the command line, the JVM automatically knows which class contains the entry point into the program (the main function), but in IDEs you must create a \"run configuration\". Both IntelliJ and Eclipse have \"run\" menus, from which you can select an option to edit the run configurations. You want to create a configuration for a Java Application, specifying the main class org.opentripplanner.standalone.OTPMain . Unlike on the command line, the arguments to the JVM and to the main class you are running are specified separately. In the field for the VM options you'll want to put your maximum memory parameter ( -Xmx2G , or whatever limit you want to place on JVM memory usage). The rest of the parameters to OTP itself will go in a different field with a name like \"program arguments\". Contributing to the project OpenTripPlanner is a community based open source project, and we welcome all who wish to contribute. There are several ways to get involved: Join the developer mailing list Fix typos and improve the documentation on the wiki or within the /docs directory of the project (details below). File a bug or new feature request . Submit patches. If you're not yet a committer, please provide patches as pull requests citing the relevant issue. Even when you do have push access to the repository, pull requests are a good way to get feedback on changes. Branches and Branch Protection As of January 2019, we have begun work on OTP 2.x and are using a Git branching model derived from Gitflow . All development will occur on the dev-1.x and dev-2.x branches. Only release commits setting the Maven artifact version to a non-snapshot number should be pushed to the master branch of OTP. All other changes to master should result from fast-forward merges of a Github pull request from the dev-1.x branch. In turn, all changes to dev-1.x should result from a fast-forward merge of a Github pull request for a single feature, fix, or other change. These pull requests are subject to code review. We require two pull request approvals from OTP leadership committee members or designated code reviewers from two different organizations. We also have validation rules ensuring that the code compiles and all tests pass before pull requests can be merged. The dev-2.x branch is managed similarly to dev-1.x but because it's rapidly changing experimental code worked on by relatively few people, we require only one pull request approval from a different organization than the author. Merges will not occur into master from dev-2.x until that branch is sufficiently advanced and receives approval from the OTP project leadership committee. Issues and commits All commits should reference a specific issue number (this was formally decided in issue #175). For example, Simplify module X configuration #9999 . If no ticket exists for the feature or bug your code implements or fixes, you should create a new ticket prior to checking in, or ideally even prior to your development work since this provides a place to carry out implementation discussions (in the comments). GitHub will automatically update issues when commits are merged in: if your commit message includes the text fixes #123 , it will automatically append your message as a comment on the isse and close it. If you simply mention #123 in your message, your message will be appended to the issue but it will remain open. Many other expressions exist to close issues via commit messages. See the GitHub help page on this topic . Code Comments As a matter of policy , all new methods, classes, and fields should include comments explaining what they are for and any other pertinent information. For Java code, the comments should use the JavaDoc conventions . It is best to provide comments that not only explain what you did but also why you did it while providing some context. Please avoid including trivial Javadoc or the empty Javadoc stubs added by IDEs, such as @param annotations with no description. Documentation Most documentation should be included directly in the OpenTripPlanner repository rather than the GitHub wiki. This allows version control to be applied to documentation as well as program source code. All pull requests that change how OTP is used or configured should include changes to the documentation alongside code modifications. Pages that help organize development teams or serve as scratchpads can still go on the wiki , but all documentation that would be of interest to people configuring or using OTP belong in the repo . The documentation files are in Markdown format and are in the /docs directory under the root of the project. On every push to the master branch the documentation will be rebuilt and deployed as static pages to our subdomain of ReadTheDocs . MkDocs is a Python program and should run on any major platform. See http://www.mkdocs.org/ for information on how to install it and how to generate a live local preview of the documentation while you're working on writing it. In short: $ pip install mkdocs $ mkdocs serve Debug layers Adding new renderer is very easy. You just need to create new class (preferably in org.opentripplanner.inspector package) which implements EdgeVertexRenderer. It is best if class name ends with Rendered. To implement this interface you need to write three functions renderEdge , renderVertex and getName . Both render functions accepts EdgeVisualAttributes object in which label of edge/vertex and color can be set. And both return true if edge/vertex should be rendered and false otherwise. getName function should return short descriptive name of the class and will be shown in layer chooser. For examples how to write renderers you can look into example renderers which are all in org.opentripplanner.inspector package. After your class is written you only need to add it to TileRenderManager: //This is how Wheelchair renderer is added renderers . put ( \"wheelchair\" , new EdgeVertexTileRenderer ( new WheelchairEdgeRenderer ())); wheelchair is internal layer key and should consist of a-zA-Z and -. By default all the tiles have cache headers to cache them for one hour. This can become problematic if you are changing renderers a lot. To disable this change GraphInspectorTileResource : //This lines CacheControl cc = new CacheControl (); cc . setMaxAge ( 3600 ); cc . setNoCache ( false ); //to this: CacheControl cc = new CacheControl (); cc . setNoCache ( true ); Date format Please use only ISO 8601 date format (YYYY-MM-DD) in documentation, comments, and throughout the project. This avoids the ambiguity that can result from differing local interpretations of date formats like 02/01/12. Project proposals and decision making Decisions are made by the OpenTripPlanner community through a proposal and informal voting process on the project mailing list . While we do vote on proposals, we don't vote in a strict democratic sense, but rather as a way to easily register opinions, foster discussion, and move toward consensus. When responding to a proposal, we use the following system: +1 - I support this +0 - I don't have a strong opinion, but I'm not opposed -0 - I'm against this, but I don't have a good alternative / I'm not willing to do the work on the alternative / I won't block -1 - Blocking no (note: in general and when appropriate, this requires the blocker to propose something else that he/she would help put the time into doing) A proposal does not need to be a formal or lengthy document; it can and should be a straightforward recommendation of what you want to do, ideally with a brief explanation for why it's a good idea. Proposals are just messages sent to the list and can be as simple as \"I think we should do X because of Y and Z. Deadline for response is 2015-10-29. Assuming I've heard no blocking votes by then, I'll go ahead.\" Note that you should make sure to include a deadline by which you will go ahead and do what you're proposing if you don't hear any blocking responses. In general, you should leave at least 72 hours for people to respond. This is not a hard-and-fast rule and you should use your best judgement in determining how far in the future the deadline should be depending on the magnitude of the proposal and how much it will affect the overall project and the rest of the community. Of course you may always fork the OTP repo on GitHub and submit your changes as a pull request, or develop and share whatever features you like on your fork even if they are not included in mainline OTP. Code style Java OpenTripPlanner uses the same code formatting and style as the GeoTools and GeoServer projects. It's a minor variant of the Sun coding convention . Notably, we do not use tabs for indentation and we allow for lines up to 100 characters wide. The Eclipse formatter configuration supplied by the GeoTools project allows comments up to 150 characters wide. A modified version included in the OpenTripPlanner repository will wrap comments to the same width as lines of code, which makes for easier reading in narrow windows (e.g. when several documents are open side-by-side on a wide display). If you use Eclipse, you should do the following to make sure your code is automatically formatted correctly: Open the project Properties (right-click on the project directory in Eclipse and select Properties or choose Project -> Properties ). Select Java , then Code Style , and finally Formatter . Check the Enable project specific settings checkbox. Click Import... , select the formatter.xml file in the root of the OpenTripPlanner git repository, and click Open . Click OK to close the Properties window. JavaScript As of #206, we follow Crockford's JavaScript code conventions . Further guidelines include: All .js source files should contain one class only Capitalize the class name, as well as the source file name (a la Java) Include the GNU LGPL header at top of file, i.e., /* This program is free software:...*/ Include the namespace definition in each and every file: otp.namespace(\"otp.configure\"); Include a class comment. For example, /** * Configure Class * * Purpose is to allow a generic configuration object to be read via AJAX/JSON, and inserted into an Ext Store * The implementation is TriMet route map specific...but replacing ConfigureStore object (or member variables) with * another implementation, will give this widget flexibility for other uses beyond the iMap. * * @class */ Note: There is still a lot of code following other style conventions, but please adhere to consistent style when you write new code, and help clean up and reformat code as you refactor. Continuous Integration The OpenTripPlanner project uses the Travis CI continuous integration system . Any time a change is pushed to the main OpenTripPlanner repository on GitHub, this server will compile and test the new code, providing feedback on the stability of the build. Release Process This section serves as a checklist for the person performing releases. Note that much of this mimics the actions taken by the Maven release plugin. Based on past experience, the Maven release plugin can fail at various points in the process leaving the repo in a confusing state. Taking each action manually is more tedious, but keeps eyes on each step and is less prone to failure. Releases are performed off the master branch, and are tagged with git annotated tags. Check that your local copy of the dev branch is up to date with no uncommitted changes git status git checkout dev-1.x git clean -df git pull Verify that all dependencies in the POM are non-SNAPSHOT versions Currently we do have one SNAPSHOT dependency on crosby.binary.osmpbf which we are working to eliminate Update docs/Changelog.md Lines should have been added or updated as each pull request was merged If you suspect any changes are not reflected in the Changelog, review the commit log and add any missing items Update the header at the top of the list from x.y.z-SNAPSHOT to just x.y.z (current date) Check in any changes, and push to Github Check on Travis that the build is currently passing Link to OTP builds on Travis CI Switch to the HEAD of master branch, and ensure it's up to date with no uncommitted changes git checkout master git status git clean -df git pull Merge the dev branch into master git merge dev-1.x Bump the SNAPSHOT version in the POM to the release version Edit version in POM, removing SNAPSHOT and increasing version numbers as needed (following semantic versioning) git add pom.xml git commit -m \"prepare release x.y.z\" Run a test build of the release locally, without deploying it mvn clean install site The install goal will sign the Maven artifacts so you need the GPG signing certificate set up You can also use the package goal instead of the install goal to avoid signing if you don't have the GPG certificate installed. All tests should pass This build will also create Enunciate API docs and Javadoc with the correct non-snapshot version number Deploy the documentation to AWS S3 You have to do this right after the test release build to ensure the right version number in the docs You will need AWSCLI tools ( sudo pip install -U awscli ) You will need AWS credentials with write access to the bucket s3://dev.opentripplanner.org aws s3 cp --recursive target/site/apidocs s3://dev.opentripplanner.org/javadoc/x.y.z --acl public-read aws s3 cp --recursive target/site/enunciate/apidocs s3://dev.opentripplanner.org/apidoc/x.y.z --acl public-read Check that docs are readable and show the correct version via the development documentation landing page . Finally, if everything looks good, tag and push this release to make it official and trigger deployment git tag -a vX.Y.Z -m \"release X.Y.Z\" git push origin vX.Y.Z Pushing the tag will trigger a Travis CI build and deployment of release Maven artifacts Note that only one commit may have a particular non-snapshot version in the POM (this is the commit that should be tagged as the release) Set up next development iteration Add a new section header to docs/Changelog.md like x.y+1.0-SNAPSHOT (in progress) Edit minor version in pom.xml to x.y+1.0-SNAPSHOT git add pom.xml docs/Changelog.md git commit -m \"Prepare next development iteration x.y+1.0-SNAPSHOT\" git push Check that Travis CI build of the release tag succeeded Link to OTP builds on Travis CI Check the end of the build log to make sure the Maven artifacts were staged for release Check that Maven artifact appears on Maven Central (deployment succeeded) Directory listing of OTP releases on Maven Central It may take a while (half an hour) for releases to show up in the central repo after Travis uploads the artifacts Merge master back into dev (to sync up the Maven artifact version from the POM) git checkout dev-1.x git merge master git push Make sure the main documentation is built For some reason it doesn't always build automatically Go to builds of docs.opentripplanner.org Click \"build version: latest\" Email the OTP dev and users mailing lists Mention the new version number. Provide links to the new developer documentation. Provide links to the artifacts directory on Maven Central. Trigger build of latest OTP documentation on Readthedocs. Additional Information on Releases OpenTripPlanner is released as Maven artifacts to Maven Central. These include compiled and source code JARs as well as a \"shaded\" JAR containing all dependencies, allowing stand-alone usage. This release process is handled by the Sonatype Nexus Staging plugin, configured in the OpenTripPlanner POM. Typically this final Maven deployment action is performed automatically when the Travis CI build succeeds in building a non-SNAPSHOT version. Artifact Signing Maven release artifacts must be digitally signed to prove their origin. This is a safeguard against compromised code from a malicious third party being disguised as a trusted library. The OTP artifact signing key was created by Conveyal. We export only that signing subkey, with our company's main key blanked out. Therefore, even if someone managed to acquire the decrypted key file and the associated GPG passphrase, they would not have the main key. We could deactivate the signing key and create a new one, without the main key being compromised. The exported signing key is present in the root of the git repo as the encrypted file maven-artifact-signing-key.asc.enc . When building a tagged release, Travis CI will decrypt this file and import it into GPG on the build machine. The signing key ID and GPG passphrase are also present as encrypted environment variables in the Travis configuration YAML. This only happens on code from non-fork, non-pull-request commits, ensuring that no unreviewed third-party code has access to these files or variables. OpenTripPlanner's POM is set up to sign artifacts in the verify phase, which means signing will happen for the install and deploy targets, but not the package target. When performing a local test build, if you do mvn clean install site it will test the signing process. If you do not have the certificate installed, you can instead to mvn clean package site to bypass signing, but this provides less certainty that everything is set up correctly for the CI-driven final release. Documentation Build and Hosting Three kinds of documentation are built for OTP, all based on information present in the OTP repo itself. The REST API docs are built by Enunciate from the OTP REST interface. My sense is that this auto-generated documentation has become harder to read and less useful over time, perhaps because of incorrect handling of REST parameters inherited from superclasses. The Javadoc is built from Javadoc comments in the source code itself. The main OTP user documentation is built from Markdown files in the /docs directory of the repo. The REST API docs and Javadoc are built by Maven, then uploaded manually to AWS S3, from which they are served as a web page at dev.opentripplanner.org. The main OTP user documentation is built by Readthedocs and served at docs.opentripplanner.org. Upload to the S3 bucket dev.opentripplanner.org requires AWS IAM credentials that can be created by Conveyal (which owns the dev.opentripplanner.org bucket).","title":"Developers' Guide"},{"location":"Developers-Guide/#developers-guide","text":"","title":"Developers Guide"},{"location":"Developers-Guide/#working-on-otp-in-an-ide","text":"Most people writing or modifying OTP code use an Integrated Development Environment (IDE). Some of the most popular IDEs for Java development are Eclipse , IntelliJ IDEA , and NetBeans . All three of these environments are good for working on OTP, and any IDE with Maven build support should also work (ensure that you have the Maven plugins installed and enabled). Git integration is a plus since OTP is under Git version control. Many of the Core OTP developers use IntelliJ IDEA. It is an excellent IDE, and in my experience is quicker and more stable than the competition. IntelliJ IDEA is a commercial product, but there is an open source \"community edition\" that is completely sufficient for working on OTP. Rather than using the version control support in my IDE, I usually find it more straightforward to clone the OTP GitHub repository manually (on the command line or using some other Git interface tool), then import the resulting local OTP repository into my IDE as a Maven project. The IDE should then take care of fetching all the libraries OTP depends on, based on the Maven project description (POM file) in the base of the OTP repository. This step can take a long time because it involves downloading a lot of JAR files. When running your local copy of the OTP source within an IDE, all command line switches and configuration options will be identical to the ones used when running the OTP JAR from the command line (as described in the basic introduction and configuration reference ). The only difference is that you need to manually specify the main class. When you run a JAR from the command line, the JVM automatically knows which class contains the entry point into the program (the main function), but in IDEs you must create a \"run configuration\". Both IntelliJ and Eclipse have \"run\" menus, from which you can select an option to edit the run configurations. You want to create a configuration for a Java Application, specifying the main class org.opentripplanner.standalone.OTPMain . Unlike on the command line, the arguments to the JVM and to the main class you are running are specified separately. In the field for the VM options you'll want to put your maximum memory parameter ( -Xmx2G , or whatever limit you want to place on JVM memory usage). The rest of the parameters to OTP itself will go in a different field with a name like \"program arguments\".","title":"Working on OTP in an IDE"},{"location":"Developers-Guide/#contributing-to-the-project","text":"OpenTripPlanner is a community based open source project, and we welcome all who wish to contribute. There are several ways to get involved: Join the developer mailing list Fix typos and improve the documentation on the wiki or within the /docs directory of the project (details below). File a bug or new feature request . Submit patches. If you're not yet a committer, please provide patches as pull requests citing the relevant issue. Even when you do have push access to the repository, pull requests are a good way to get feedback on changes.","title":"Contributing to the project"},{"location":"Developers-Guide/#branches-and-branch-protection","text":"As of January 2019, we have begun work on OTP 2.x and are using a Git branching model derived from Gitflow . All development will occur on the dev-1.x and dev-2.x branches. Only release commits setting the Maven artifact version to a non-snapshot number should be pushed to the master branch of OTP. All other changes to master should result from fast-forward merges of a Github pull request from the dev-1.x branch. In turn, all changes to dev-1.x should result from a fast-forward merge of a Github pull request for a single feature, fix, or other change. These pull requests are subject to code review. We require two pull request approvals from OTP leadership committee members or designated code reviewers from two different organizations. We also have validation rules ensuring that the code compiles and all tests pass before pull requests can be merged. The dev-2.x branch is managed similarly to dev-1.x but because it's rapidly changing experimental code worked on by relatively few people, we require only one pull request approval from a different organization than the author. Merges will not occur into master from dev-2.x until that branch is sufficiently advanced and receives approval from the OTP project leadership committee.","title":"Branches and Branch Protection"},{"location":"Developers-Guide/#issues-and-commits","text":"All commits should reference a specific issue number (this was formally decided in issue #175). For example, Simplify module X configuration #9999 . If no ticket exists for the feature or bug your code implements or fixes, you should create a new ticket prior to checking in, or ideally even prior to your development work since this provides a place to carry out implementation discussions (in the comments). GitHub will automatically update issues when commits are merged in: if your commit message includes the text fixes #123 , it will automatically append your message as a comment on the isse and close it. If you simply mention #123 in your message, your message will be appended to the issue but it will remain open. Many other expressions exist to close issues via commit messages. See the GitHub help page on this topic .","title":"Issues and commits"},{"location":"Developers-Guide/#code-comments","text":"As a matter of policy , all new methods, classes, and fields should include comments explaining what they are for and any other pertinent information. For Java code, the comments should use the JavaDoc conventions . It is best to provide comments that not only explain what you did but also why you did it while providing some context. Please avoid including trivial Javadoc or the empty Javadoc stubs added by IDEs, such as @param annotations with no description.","title":"Code Comments"},{"location":"Developers-Guide/#documentation","text":"Most documentation should be included directly in the OpenTripPlanner repository rather than the GitHub wiki. This allows version control to be applied to documentation as well as program source code. All pull requests that change how OTP is used or configured should include changes to the documentation alongside code modifications. Pages that help organize development teams or serve as scratchpads can still go on the wiki , but all documentation that would be of interest to people configuring or using OTP belong in the repo . The documentation files are in Markdown format and are in the /docs directory under the root of the project. On every push to the master branch the documentation will be rebuilt and deployed as static pages to our subdomain of ReadTheDocs . MkDocs is a Python program and should run on any major platform. See http://www.mkdocs.org/ for information on how to install it and how to generate a live local preview of the documentation while you're working on writing it. In short: $ pip install mkdocs $ mkdocs serve","title":"Documentation"},{"location":"Developers-Guide/#debug-layers","text":"Adding new renderer is very easy. You just need to create new class (preferably in org.opentripplanner.inspector package) which implements EdgeVertexRenderer. It is best if class name ends with Rendered. To implement this interface you need to write three functions renderEdge , renderVertex and getName . Both render functions accepts EdgeVisualAttributes object in which label of edge/vertex and color can be set. And both return true if edge/vertex should be rendered and false otherwise. getName function should return short descriptive name of the class and will be shown in layer chooser. For examples how to write renderers you can look into example renderers which are all in org.opentripplanner.inspector package. After your class is written you only need to add it to TileRenderManager: //This is how Wheelchair renderer is added renderers . put ( \"wheelchair\" , new EdgeVertexTileRenderer ( new WheelchairEdgeRenderer ())); wheelchair is internal layer key and should consist of a-zA-Z and -. By default all the tiles have cache headers to cache them for one hour. This can become problematic if you are changing renderers a lot. To disable this change GraphInspectorTileResource : //This lines CacheControl cc = new CacheControl (); cc . setMaxAge ( 3600 ); cc . setNoCache ( false ); //to this: CacheControl cc = new CacheControl (); cc . setNoCache ( true );","title":"Debug layers"},{"location":"Developers-Guide/#date-format","text":"Please use only ISO 8601 date format (YYYY-MM-DD) in documentation, comments, and throughout the project. This avoids the ambiguity that can result from differing local interpretations of date formats like 02/01/12.","title":"Date format"},{"location":"Developers-Guide/#project-proposals-and-decision-making","text":"Decisions are made by the OpenTripPlanner community through a proposal and informal voting process on the project mailing list . While we do vote on proposals, we don't vote in a strict democratic sense, but rather as a way to easily register opinions, foster discussion, and move toward consensus. When responding to a proposal, we use the following system: +1 - I support this +0 - I don't have a strong opinion, but I'm not opposed -0 - I'm against this, but I don't have a good alternative / I'm not willing to do the work on the alternative / I won't block -1 - Blocking no (note: in general and when appropriate, this requires the blocker to propose something else that he/she would help put the time into doing) A proposal does not need to be a formal or lengthy document; it can and should be a straightforward recommendation of what you want to do, ideally with a brief explanation for why it's a good idea. Proposals are just messages sent to the list and can be as simple as \"I think we should do X because of Y and Z. Deadline for response is 2015-10-29. Assuming I've heard no blocking votes by then, I'll go ahead.\" Note that you should make sure to include a deadline by which you will go ahead and do what you're proposing if you don't hear any blocking responses. In general, you should leave at least 72 hours for people to respond. This is not a hard-and-fast rule and you should use your best judgement in determining how far in the future the deadline should be depending on the magnitude of the proposal and how much it will affect the overall project and the rest of the community. Of course you may always fork the OTP repo on GitHub and submit your changes as a pull request, or develop and share whatever features you like on your fork even if they are not included in mainline OTP.","title":"Project proposals and decision making"},{"location":"Developers-Guide/#code-style","text":"","title":"Code style"},{"location":"Developers-Guide/#java","text":"OpenTripPlanner uses the same code formatting and style as the GeoTools and GeoServer projects. It's a minor variant of the Sun coding convention . Notably, we do not use tabs for indentation and we allow for lines up to 100 characters wide. The Eclipse formatter configuration supplied by the GeoTools project allows comments up to 150 characters wide. A modified version included in the OpenTripPlanner repository will wrap comments to the same width as lines of code, which makes for easier reading in narrow windows (e.g. when several documents are open side-by-side on a wide display). If you use Eclipse, you should do the following to make sure your code is automatically formatted correctly: Open the project Properties (right-click on the project directory in Eclipse and select Properties or choose Project -> Properties ). Select Java , then Code Style , and finally Formatter . Check the Enable project specific settings checkbox. Click Import... , select the formatter.xml file in the root of the OpenTripPlanner git repository, and click Open . Click OK to close the Properties window.","title":"Java"},{"location":"Developers-Guide/#javascript","text":"As of #206, we follow Crockford's JavaScript code conventions . Further guidelines include: All .js source files should contain one class only Capitalize the class name, as well as the source file name (a la Java) Include the GNU LGPL header at top of file, i.e., /* This program is free software:...*/ Include the namespace definition in each and every file: otp.namespace(\"otp.configure\"); Include a class comment. For example, /** * Configure Class * * Purpose is to allow a generic configuration object to be read via AJAX/JSON, and inserted into an Ext Store * The implementation is TriMet route map specific...but replacing ConfigureStore object (or member variables) with * another implementation, will give this widget flexibility for other uses beyond the iMap. * * @class */ Note: There is still a lot of code following other style conventions, but please adhere to consistent style when you write new code, and help clean up and reformat code as you refactor.","title":"JavaScript"},{"location":"Developers-Guide/#continuous-integration","text":"The OpenTripPlanner project uses the Travis CI continuous integration system . Any time a change is pushed to the main OpenTripPlanner repository on GitHub, this server will compile and test the new code, providing feedback on the stability of the build.","title":"Continuous Integration"},{"location":"Developers-Guide/#release-process","text":"This section serves as a checklist for the person performing releases. Note that much of this mimics the actions taken by the Maven release plugin. Based on past experience, the Maven release plugin can fail at various points in the process leaving the repo in a confusing state. Taking each action manually is more tedious, but keeps eyes on each step and is less prone to failure. Releases are performed off the master branch, and are tagged with git annotated tags. Check that your local copy of the dev branch is up to date with no uncommitted changes git status git checkout dev-1.x git clean -df git pull Verify that all dependencies in the POM are non-SNAPSHOT versions Currently we do have one SNAPSHOT dependency on crosby.binary.osmpbf which we are working to eliminate Update docs/Changelog.md Lines should have been added or updated as each pull request was merged If you suspect any changes are not reflected in the Changelog, review the commit log and add any missing items Update the header at the top of the list from x.y.z-SNAPSHOT to just x.y.z (current date) Check in any changes, and push to Github Check on Travis that the build is currently passing Link to OTP builds on Travis CI Switch to the HEAD of master branch, and ensure it's up to date with no uncommitted changes git checkout master git status git clean -df git pull Merge the dev branch into master git merge dev-1.x Bump the SNAPSHOT version in the POM to the release version Edit version in POM, removing SNAPSHOT and increasing version numbers as needed (following semantic versioning) git add pom.xml git commit -m \"prepare release x.y.z\" Run a test build of the release locally, without deploying it mvn clean install site The install goal will sign the Maven artifacts so you need the GPG signing certificate set up You can also use the package goal instead of the install goal to avoid signing if you don't have the GPG certificate installed. All tests should pass This build will also create Enunciate API docs and Javadoc with the correct non-snapshot version number Deploy the documentation to AWS S3 You have to do this right after the test release build to ensure the right version number in the docs You will need AWSCLI tools ( sudo pip install -U awscli ) You will need AWS credentials with write access to the bucket s3://dev.opentripplanner.org aws s3 cp --recursive target/site/apidocs s3://dev.opentripplanner.org/javadoc/x.y.z --acl public-read aws s3 cp --recursive target/site/enunciate/apidocs s3://dev.opentripplanner.org/apidoc/x.y.z --acl public-read Check that docs are readable and show the correct version via the development documentation landing page . Finally, if everything looks good, tag and push this release to make it official and trigger deployment git tag -a vX.Y.Z -m \"release X.Y.Z\" git push origin vX.Y.Z Pushing the tag will trigger a Travis CI build and deployment of release Maven artifacts Note that only one commit may have a particular non-snapshot version in the POM (this is the commit that should be tagged as the release) Set up next development iteration Add a new section header to docs/Changelog.md like x.y+1.0-SNAPSHOT (in progress) Edit minor version in pom.xml to x.y+1.0-SNAPSHOT git add pom.xml docs/Changelog.md git commit -m \"Prepare next development iteration x.y+1.0-SNAPSHOT\" git push Check that Travis CI build of the release tag succeeded Link to OTP builds on Travis CI Check the end of the build log to make sure the Maven artifacts were staged for release Check that Maven artifact appears on Maven Central (deployment succeeded) Directory listing of OTP releases on Maven Central It may take a while (half an hour) for releases to show up in the central repo after Travis uploads the artifacts Merge master back into dev (to sync up the Maven artifact version from the POM) git checkout dev-1.x git merge master git push Make sure the main documentation is built For some reason it doesn't always build automatically Go to builds of docs.opentripplanner.org Click \"build version: latest\" Email the OTP dev and users mailing lists Mention the new version number. Provide links to the new developer documentation. Provide links to the artifacts directory on Maven Central. Trigger build of latest OTP documentation on Readthedocs.","title":"Release Process"},{"location":"Developers-Guide/#additional-information-on-releases","text":"OpenTripPlanner is released as Maven artifacts to Maven Central. These include compiled and source code JARs as well as a \"shaded\" JAR containing all dependencies, allowing stand-alone usage. This release process is handled by the Sonatype Nexus Staging plugin, configured in the OpenTripPlanner POM. Typically this final Maven deployment action is performed automatically when the Travis CI build succeeds in building a non-SNAPSHOT version.","title":"Additional Information on Releases"},{"location":"Developers-Guide/#artifact-signing","text":"Maven release artifacts must be digitally signed to prove their origin. This is a safeguard against compromised code from a malicious third party being disguised as a trusted library. The OTP artifact signing key was created by Conveyal. We export only that signing subkey, with our company's main key blanked out. Therefore, even if someone managed to acquire the decrypted key file and the associated GPG passphrase, they would not have the main key. We could deactivate the signing key and create a new one, without the main key being compromised. The exported signing key is present in the root of the git repo as the encrypted file maven-artifact-signing-key.asc.enc . When building a tagged release, Travis CI will decrypt this file and import it into GPG on the build machine. The signing key ID and GPG passphrase are also present as encrypted environment variables in the Travis configuration YAML. This only happens on code from non-fork, non-pull-request commits, ensuring that no unreviewed third-party code has access to these files or variables. OpenTripPlanner's POM is set up to sign artifacts in the verify phase, which means signing will happen for the install and deploy targets, but not the package target. When performing a local test build, if you do mvn clean install site it will test the signing process. If you do not have the certificate installed, you can instead to mvn clean package site to bypass signing, but this provides less certainty that everything is set up correctly for the CI-driven final release.","title":"Artifact Signing"},{"location":"Developers-Guide/#documentation-build-and-hosting","text":"Three kinds of documentation are built for OTP, all based on information present in the OTP repo itself. The REST API docs are built by Enunciate from the OTP REST interface. My sense is that this auto-generated documentation has become harder to read and less useful over time, perhaps because of incorrect handling of REST parameters inherited from superclasses. The Javadoc is built from Javadoc comments in the source code itself. The main OTP user documentation is built from Markdown files in the /docs directory of the repo. The REST API docs and Javadoc are built by Maven, then uploaded manually to AWS S3, from which they are served as a web page at dev.opentripplanner.org. The main OTP user documentation is built by Readthedocs and served at docs.opentripplanner.org. Upload to the S3 bucket dev.opentripplanner.org requires AWS IAM credentials that can be created by Conveyal (which owns the dev.opentripplanner.org bucket).","title":"Documentation Build and Hosting"},{"location":"External-Tutorials/","text":"External Resources Marcus Young has contributed a tutorial used at a workshop held at the University of Leeds in November of 2017. The tutorial is available on Github as a PDF file with an associated ZIP file of input data .","title":"External Tutorials"},{"location":"External-Tutorials/#external-resources","text":"Marcus Young has contributed a tutorial used at a workshop held at the University of Leeds in November of 2017. The tutorial is available on Github as a PDF file with an associated ZIP file of input data .","title":"External Resources"},{"location":"Flex/","text":"GTFS-Flex routing Many agencies run flexible services to complement their fixed-route service. \"Flexible\" service does not follow a strict timetable or route. It may include any of the following features: boardings or alightings outside its scheduled timetable and route; booking and scheduling in advance; or transit parameters which depend on customer requests (\"demand-responsive transit\" or DRT). These services are typically used in rural areas or for mobility-impaired riders. A GTFS extension called GTFS-Flex defines how to model some kinds of flexible transit. A subset of GTFS-Flex has been implemented in OpenTripPlanner as part of US DOT's Mobility-on-Demand Sandbox Grant . In particular, OTP now has support for these modes of GTFS-Flex: \"flag stops\", in which a passenger can flag down the a vehicle along its route to board, or alight in between stops \"deviated-route service\", in which a vehicle can deviate from its route within an area or radius to do a dropoff or pickup \"call-and-ride\", which is an entirely deviated, point-to-point segment. These modes can co-exist with fixed-route transit, and with each other. For example, some agencies have fixed-route services that start in urban areas, where passengers must board at designated stops, but end in rural areas where passengers can board and alight wherever they please. A fixed-route service may terminate in an defined area where it can drop off passengers anywhere -- or have such an area at the beginning or middle of its route. A vehicle may be able to deviate a certain radius outside its scheduled route to pick up or drop off passengers. If both a pickup and dropoff occur in between scheduled timepoints, from the passenger's perspective, the service may look like a call-and-ride trip. Other call-and-ride services may operate more like taxis, in which all rides are independently scheduled. Configuration In order to use flexible routing, an OTP graph must be built with a GTFS-Flex dataset and OpenStreetMap data. The GTFS data must include shapes.txt . In addition, the parameter useFlexService: true must be added to router-config.json . A number of routing parameters can be used to control aspects of flexible service. These parameters typically change the relative cost of using various flexible services relative to fixed-route transit. All flex-related parameters begin with the prefix \"flex\" and can be found in the Javadocs for RoutingRequest.java . The following example router-config.json enables flexible routing and sets some parameters: { \"useFlexService\": true, \"routingDefaults\": { \"flexCallAndRideReluctance\": 3, \"flexMaxCallAndRideSeconds\": 7200, \"flexFlagStopExtraPenalty\": 180 } } Implementation The general approach of the GTFS-Flex implementation is as follows: prior to the main graph search, special searches are run around the origin and destination to discover possible flexible options. One search is with the WALK mode, to find flag stops, and the other is in the CAR mode, to find deviated-route and call-and-ride options. These searches result in the creation of temporary, request-specific vertices and edges. Then, the graph search proceeds as normal. Temporary graph structures are disposed at the end of the request's lifecycle. For flag stops and deviated-route service, timepoints in between scheduled locations are determined via linear interpolation. For example, say a particular trip departs stop A at 9:00am and arrives at stop B at 9:30am. A passenger would be able to board 20% of the way in between stop A and stop B at 9:06am, since 20% of 30 minutes is 6 minutes. For deviated-route service and call-and-ride service, the most pessimistic assumptions of vehicle travel time are used -- e.g. vehicle travel time is calculated via the drt_max_travel_time formula in the GTFS-Flex (see the spec here ).","title":"GTFS-Flex Routing"},{"location":"Flex/#gtfs-flex-routing","text":"Many agencies run flexible services to complement their fixed-route service. \"Flexible\" service does not follow a strict timetable or route. It may include any of the following features: boardings or alightings outside its scheduled timetable and route; booking and scheduling in advance; or transit parameters which depend on customer requests (\"demand-responsive transit\" or DRT). These services are typically used in rural areas or for mobility-impaired riders. A GTFS extension called GTFS-Flex defines how to model some kinds of flexible transit. A subset of GTFS-Flex has been implemented in OpenTripPlanner as part of US DOT's Mobility-on-Demand Sandbox Grant . In particular, OTP now has support for these modes of GTFS-Flex: \"flag stops\", in which a passenger can flag down the a vehicle along its route to board, or alight in between stops \"deviated-route service\", in which a vehicle can deviate from its route within an area or radius to do a dropoff or pickup \"call-and-ride\", which is an entirely deviated, point-to-point segment. These modes can co-exist with fixed-route transit, and with each other. For example, some agencies have fixed-route services that start in urban areas, where passengers must board at designated stops, but end in rural areas where passengers can board and alight wherever they please. A fixed-route service may terminate in an defined area where it can drop off passengers anywhere -- or have such an area at the beginning or middle of its route. A vehicle may be able to deviate a certain radius outside its scheduled route to pick up or drop off passengers. If both a pickup and dropoff occur in between scheduled timepoints, from the passenger's perspective, the service may look like a call-and-ride trip. Other call-and-ride services may operate more like taxis, in which all rides are independently scheduled.","title":"GTFS-Flex routing"},{"location":"Flex/#configuration","text":"In order to use flexible routing, an OTP graph must be built with a GTFS-Flex dataset and OpenStreetMap data. The GTFS data must include shapes.txt . In addition, the parameter useFlexService: true must be added to router-config.json . A number of routing parameters can be used to control aspects of flexible service. These parameters typically change the relative cost of using various flexible services relative to fixed-route transit. All flex-related parameters begin with the prefix \"flex\" and can be found in the Javadocs for RoutingRequest.java . The following example router-config.json enables flexible routing and sets some parameters: { \"useFlexService\": true, \"routingDefaults\": { \"flexCallAndRideReluctance\": 3, \"flexMaxCallAndRideSeconds\": 7200, \"flexFlagStopExtraPenalty\": 180 } }","title":"Configuration"},{"location":"Flex/#implementation","text":"The general approach of the GTFS-Flex implementation is as follows: prior to the main graph search, special searches are run around the origin and destination to discover possible flexible options. One search is with the WALK mode, to find flag stops, and the other is in the CAR mode, to find deviated-route and call-and-ride options. These searches result in the creation of temporary, request-specific vertices and edges. Then, the graph search proceeds as normal. Temporary graph structures are disposed at the end of the request's lifecycle. For flag stops and deviated-route service, timepoints in between scheduled locations are determined via linear interpolation. For example, say a particular trip departs stop A at 9:00am and arrives at stop B at 9:30am. A passenger would be able to board 20% of the way in between stop A and stop B at 9:06am, since 20% of 30 minutes is 6 minutes. For deviated-route service and call-and-ride service, the most pessimistic assumptions of vehicle travel time are used -- e.g. vehicle travel time is calculated via the drt_max_travel_time formula in the GTFS-Flex (see the spec here ).","title":"Implementation"},{"location":"Getting-OTP/","text":"Getting OpenTripPlanner Pre-built JARs OpenTripPlanner is distributed as a single stand-alone runnable JAR file. These JARs are deployed to the Sonatype OSSRH Maven repository, and release versions are synced to the Maven Central repository. Most people will want to go to the OTP directory at Maven Central , navigate to the directory for the highest version number, and download the file whose name ends with .shaded.jar . We use the Travis continuous integration system to build OTP every time a change is made. You can find the JARs resulting from those builds in the OSSRH staging repository . A directory named x.y.z-SNAPSHOT contain JARs for builds leading up to (preceding) the x.y.z release. Files within SNAPSHOT directories are named using the date and time that the build occurred. Building from Source You may also choose to build OTP from its source code. If you will be modifying OTP you will need to know how to rebuild it (though your IDE may take care of this build cycle for you). If you have the right software installed, building OTP locally from its source code is not particularly difficult. You should only need the following software: Git, a version control system Java Development Kit, preferably version 8 (AKA version 1.8) Maven, a build and dependency management system You will also need a reliable internet connection so Maven can fetch all of OTP's dependencies (the libraries it uses). To install these software packages on a Debian or Ubuntu system, run: sudo apt-get install openjdk-8-jdk maven git Once you have these packages installed, create and/or switch to the directory where you will keep your Git repositories and make a local copy of the OTP source code: mkdir git cd git git clone git@github.com:opentripplanner/OpenTripPlanner.git Then change to the newly cloned OpenTripPlanner repository directory and start a build: cd OpenTripPlanner mvn clean package Maven should then be able to download all the libraries and other dependencies necessary to compile OTP. If all goes well you should see a success message like the following: [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 42.164s [INFO] Finished at: Tue Feb 18 19:35:48 CET 2014 [INFO] Final Memory: 88M/695M [INFO] ------------------------------------------------------------------------ This build process should produce a JAR file called otp-x.y.z-shaded.jar in the target/ directory which contains all the compiled OTP classes and their dependencies (the external libraries they use). The shell script called 'otp' in the root of the cloned repository will start the main class of that JAR file under a Java virtual machine, so after the Maven build completes you should be able to run ./otp --help and see an OTP help message including command line options. Due to the way Maven works, this script is not executable by default, so you will need to do chmod u+x ./otp before you run it to mark it as executable. The words \"clean package\" are the build steps you want to run. You're telling maven to clean up any extraneous junk in the directory, then perform all the build steps, including compilation, up to and including \"package\", which bundles the compiled program into a single JAR file for distribution. If you have just cloned OTP you will be working with the default \"master\" branch, where most active development occurs. This is not the most stable or deployment-ready code available. To avoid newly minted bugs or undocumented behavior, you can use Git to check out a specific release (tag or branch) of OTP to work with. The Maven build also includes many time-consuming integration tests. When working with a stable release of OTP, you may want to turn them off by adding the switch: -DskipTests . For example, you could do the following: cd OpenTripPlanner git checkout opentripplanner-0.18.0 git clean -df mvn clean package -DskipTests Please note that the build process creates two distinct versions of the OTP JAR file. The one ending in -shaded.jar is much bigger because it contains copies of all the external libraries that OTP uses. It serves as a stand-alone runnable distribution of OTP. The one with a version number but without the word shaded contains only OTP itself, without any external dependencies. This JAR is useful when OTP is included as a component in some other project, where we want the dependency management system to gather all the external libraries automatically. Maven Repository OpenTripPlanner is a Maven project. Maven is a combined build and dependency management system: it fetches all the external libraries that OTP uses, runs all the commands to compile the OTP source code into runnable form, performs tests, and can then deploy the final \"artifact\" (the runnable JAR file) to the Maven repository, from which it can be automatically included in other Java projects. This repository is machine-readable (by Maven or other build systems) and also provides human readable directory listings via HTTP. You can fetch an OTP JAR from this repository by constructing the proper URL for the release you want. For example, release 1.1.0 will be found at https://repo1.maven.org/maven2/org/opentripplanner/otp/1.1.0/otp-1.1.0-shaded.jar . To make use of OTP in another Maven project, you must specify it as a dependency in that project's pom.xml : <dependency> <groupId> org.opentripplanner </groupId> <artifactId> otp </artifactId> <version> 1.2.0 </version> </dependency> After each successful build, the Travis continuous integration system deploys the final OTP \"artifact\" (the runnable JAR) to our Maven repository as a \"SNAPSHOT\" build. This means that a Maven project depending on OTP as a library can always fetch the latest work in progress by specifying a snapshot artifact: <repositories> <repository> <id> ossrh_snapshots </id> <name> Sonatype OSSRH Shapshot Repository </name> <url> https://oss.sonatype.org/content/repositories/snapshots/ </url> </repository> </repositories> <dependency> <groupId> org.opentripplanner </groupId> <artifactId> otp </artifactId> <version> 1.2.0-SNAPSHOT </version> </dependency>","title":"Getting OTP"},{"location":"Getting-OTP/#getting-opentripplanner","text":"","title":"Getting OpenTripPlanner"},{"location":"Getting-OTP/#pre-built-jars","text":"OpenTripPlanner is distributed as a single stand-alone runnable JAR file. These JARs are deployed to the Sonatype OSSRH Maven repository, and release versions are synced to the Maven Central repository. Most people will want to go to the OTP directory at Maven Central , navigate to the directory for the highest version number, and download the file whose name ends with .shaded.jar . We use the Travis continuous integration system to build OTP every time a change is made. You can find the JARs resulting from those builds in the OSSRH staging repository . A directory named x.y.z-SNAPSHOT contain JARs for builds leading up to (preceding) the x.y.z release. Files within SNAPSHOT directories are named using the date and time that the build occurred.","title":"Pre-built JARs"},{"location":"Getting-OTP/#building-from-source","text":"You may also choose to build OTP from its source code. If you will be modifying OTP you will need to know how to rebuild it (though your IDE may take care of this build cycle for you). If you have the right software installed, building OTP locally from its source code is not particularly difficult. You should only need the following software: Git, a version control system Java Development Kit, preferably version 8 (AKA version 1.8) Maven, a build and dependency management system You will also need a reliable internet connection so Maven can fetch all of OTP's dependencies (the libraries it uses). To install these software packages on a Debian or Ubuntu system, run: sudo apt-get install openjdk-8-jdk maven git Once you have these packages installed, create and/or switch to the directory where you will keep your Git repositories and make a local copy of the OTP source code: mkdir git cd git git clone git@github.com:opentripplanner/OpenTripPlanner.git Then change to the newly cloned OpenTripPlanner repository directory and start a build: cd OpenTripPlanner mvn clean package Maven should then be able to download all the libraries and other dependencies necessary to compile OTP. If all goes well you should see a success message like the following: [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 42.164s [INFO] Finished at: Tue Feb 18 19:35:48 CET 2014 [INFO] Final Memory: 88M/695M [INFO] ------------------------------------------------------------------------ This build process should produce a JAR file called otp-x.y.z-shaded.jar in the target/ directory which contains all the compiled OTP classes and their dependencies (the external libraries they use). The shell script called 'otp' in the root of the cloned repository will start the main class of that JAR file under a Java virtual machine, so after the Maven build completes you should be able to run ./otp --help and see an OTP help message including command line options. Due to the way Maven works, this script is not executable by default, so you will need to do chmod u+x ./otp before you run it to mark it as executable. The words \"clean package\" are the build steps you want to run. You're telling maven to clean up any extraneous junk in the directory, then perform all the build steps, including compilation, up to and including \"package\", which bundles the compiled program into a single JAR file for distribution. If you have just cloned OTP you will be working with the default \"master\" branch, where most active development occurs. This is not the most stable or deployment-ready code available. To avoid newly minted bugs or undocumented behavior, you can use Git to check out a specific release (tag or branch) of OTP to work with. The Maven build also includes many time-consuming integration tests. When working with a stable release of OTP, you may want to turn them off by adding the switch: -DskipTests . For example, you could do the following: cd OpenTripPlanner git checkout opentripplanner-0.18.0 git clean -df mvn clean package -DskipTests Please note that the build process creates two distinct versions of the OTP JAR file. The one ending in -shaded.jar is much bigger because it contains copies of all the external libraries that OTP uses. It serves as a stand-alone runnable distribution of OTP. The one with a version number but without the word shaded contains only OTP itself, without any external dependencies. This JAR is useful when OTP is included as a component in some other project, where we want the dependency management system to gather all the external libraries automatically.","title":"Building from Source"},{"location":"Getting-OTP/#maven-repository","text":"OpenTripPlanner is a Maven project. Maven is a combined build and dependency management system: it fetches all the external libraries that OTP uses, runs all the commands to compile the OTP source code into runnable form, performs tests, and can then deploy the final \"artifact\" (the runnable JAR file) to the Maven repository, from which it can be automatically included in other Java projects. This repository is machine-readable (by Maven or other build systems) and also provides human readable directory listings via HTTP. You can fetch an OTP JAR from this repository by constructing the proper URL for the release you want. For example, release 1.1.0 will be found at https://repo1.maven.org/maven2/org/opentripplanner/otp/1.1.0/otp-1.1.0-shaded.jar . To make use of OTP in another Maven project, you must specify it as a dependency in that project's pom.xml : <dependency> <groupId> org.opentripplanner </groupId> <artifactId> otp </artifactId> <version> 1.2.0 </version> </dependency> After each successful build, the Travis continuous integration system deploys the final OTP \"artifact\" (the runnable JAR) to our Maven repository as a \"SNAPSHOT\" build. This means that a Maven project depending on OTP as a library can always fetch the latest work in progress by specifying a snapshot artifact: <repositories> <repository> <id> ossrh_snapshots </id> <name> Sonatype OSSRH Shapshot Repository </name> <url> https://oss.sonatype.org/content/repositories/snapshots/ </url> </repository> </repositories> <dependency> <groupId> org.opentripplanner </groupId> <artifactId> otp </artifactId> <version> 1.2.0-SNAPSHOT </version> </dependency>","title":"Maven Repository"},{"location":"Governance/","text":"Project Governance OpenTripPlanner is a member project of the Software Freedom Conservancy . Development of OpenTripPlanner is managed by a Project Leadership Committee (PLC) which makes decisions by simple majority vote. The current members of this committee are (in alphabetical order): Name Affiliation Sean Barbeau University of South Florida Sheldon Brown Cambridge Systematics Andrew Byrd Conveyal Thomas Craig Trillium Drew Dara-Abrams Interline David Emory MARTA (Atlanta, Georgia USA) Thomas Gran Ruter & Entur (Norway) Tuukka Hastrup Maanteeamet (Estonia) Joel Lappalainan Digitransit (Finland) Frank Purcell TriMet (Portland, Oregon) Evan Siroky IBI Group David Turner ex-OpenPlans The PLC holds a quarterly video conference on the first Tuesday of June, September, December, and March. An agenda is prepared as a collaborative document in advance of each quarterly meeting. These meetings are held at 9AM US Pacific time to accommodate members in the US Pacific, US Eastern, and Central European time zones. We take care to avoid a governance system that is too conceptual or process-heavy. The main goal is to have regular agenda-driven meetings that yield clear decisions and action items assigned to specific people. The committee should ideally be composed of active, professional contributors to the OpenTripPlanner project, including representatives of organizations that host official public deployments of OTP. We enfore a policy on the review and merging of new changes to the OTP system, guided by a roadmap maintained by the committee. All changes must be reviewed and approved by at least two people from two different organizations. The list of approved reviewers is the PLC Github group, visible here https://github.com/orgs/opentripplanner/teams/plc/members","title":"Governance"},{"location":"Governance/#project-governance","text":"OpenTripPlanner is a member project of the Software Freedom Conservancy . Development of OpenTripPlanner is managed by a Project Leadership Committee (PLC) which makes decisions by simple majority vote. The current members of this committee are (in alphabetical order): Name Affiliation Sean Barbeau University of South Florida Sheldon Brown Cambridge Systematics Andrew Byrd Conveyal Thomas Craig Trillium Drew Dara-Abrams Interline David Emory MARTA (Atlanta, Georgia USA) Thomas Gran Ruter & Entur (Norway) Tuukka Hastrup Maanteeamet (Estonia) Joel Lappalainan Digitransit (Finland) Frank Purcell TriMet (Portland, Oregon) Evan Siroky IBI Group David Turner ex-OpenPlans The PLC holds a quarterly video conference on the first Tuesday of June, September, December, and March. An agenda is prepared as a collaborative document in advance of each quarterly meeting. These meetings are held at 9AM US Pacific time to accommodate members in the US Pacific, US Eastern, and Central European time zones. We take care to avoid a governance system that is too conceptual or process-heavy. The main goal is to have regular agenda-driven meetings that yield clear decisions and action items assigned to specific people. The committee should ideally be composed of active, professional contributors to the OpenTripPlanner project, including representatives of organizations that host official public deployments of OTP. We enfore a policy on the review and merging of new changes to the OTP system, guided by a roadmap maintained by the committee. All changes must be reviewed and approved by at least two people from two different organizations. The list of approved reviewers is the PLC Github group, visible here https://github.com/orgs/opentripplanner/teams/plc/members","title":"Project Governance"},{"location":"History/","text":"OpenTripPlanner Project History OpenTripPlanner was seeded by Portland, Oregon's transit agency TriMet with a Regional Travel Options grant and opened with a 3-day Kick-Off Workshop in July of 2009 bringing together transit agencies and the authors of the major open source transit passenger information software of the day: David Emory of FivePoints, Brian Ferris of OneBusAway , and Brandon Martin-Anderson of Graphserver . From 2009 through 2012, development was coordinated by New York nonprofit OpenPlans . In 2011 a second workshop was held to mark the end of the first phase of development. TriMet's 2009-2011 OTP Final Report summarizes progress at that point. The project has since grown to encompass a global community of users and developers. By early 2013, OpenTripPlanner had become the primary trip planning software used by TriMet in the Portland regional trip planner and was backing several popular mobile applications. Public-facing OpenTripPlanner instances were available in at least ten countries throughout the world. At this point the OpenPlans transportation software team became the independent consultancy Conveyal . The original OpenTripPlanner development team from OpenPlans still actively participates in programming, design, and community coordination via the mailing list and their roles on the OTP Project Leadership Committee. In summer of 2013, the OpenTripPlanner project was accepted for membership in the Software Freedom Conservancy (SFC) . SFC handles the legal and financial details common to many open source projects. In 2013-2014 OpenTripPlanner was a focal point in the Dutch Transport Ministry's MMRI (MultiModal Travel Information) project which encouraged investment in trip planning platforms and services. A consortium of five companies worked together to improve OpenTripPlanner performance in large regional transport networks and account for real-time service modifications and delays. In the fall of 2014, Arlington, Virginia launched a new commute planning site for the Washington, DC metropolitan area, depending on OpenTripPlanner to weigh the costs and benefits of various travel options. In 2015 the New York State department of transportation's 511 transit trip planner began using OTP to provide itineraries for public transit systems throughout the state from a single unified OTP instance. After seven years of hard work and almost 10,000 commits from over 100 contributors around the world, OTP version 1.0 was released on 9 September 2016. Starting in early 2016, the regional transport authorities of Helsinki, Finland (HSL) and Oslo, Norway (Ruter) began using a completely open source passenger information system based on OpenTripPlanner. National-scale OpenTripPlanner instances are also maintained in Finland and Norway.","title":"History"},{"location":"History/#opentripplanner-project-history","text":"OpenTripPlanner was seeded by Portland, Oregon's transit agency TriMet with a Regional Travel Options grant and opened with a 3-day Kick-Off Workshop in July of 2009 bringing together transit agencies and the authors of the major open source transit passenger information software of the day: David Emory of FivePoints, Brian Ferris of OneBusAway , and Brandon Martin-Anderson of Graphserver . From 2009 through 2012, development was coordinated by New York nonprofit OpenPlans . In 2011 a second workshop was held to mark the end of the first phase of development. TriMet's 2009-2011 OTP Final Report summarizes progress at that point. The project has since grown to encompass a global community of users and developers. By early 2013, OpenTripPlanner had become the primary trip planning software used by TriMet in the Portland regional trip planner and was backing several popular mobile applications. Public-facing OpenTripPlanner instances were available in at least ten countries throughout the world. At this point the OpenPlans transportation software team became the independent consultancy Conveyal . The original OpenTripPlanner development team from OpenPlans still actively participates in programming, design, and community coordination via the mailing list and their roles on the OTP Project Leadership Committee. In summer of 2013, the OpenTripPlanner project was accepted for membership in the Software Freedom Conservancy (SFC) . SFC handles the legal and financial details common to many open source projects. In 2013-2014 OpenTripPlanner was a focal point in the Dutch Transport Ministry's MMRI (MultiModal Travel Information) project which encouraged investment in trip planning platforms and services. A consortium of five companies worked together to improve OpenTripPlanner performance in large regional transport networks and account for real-time service modifications and delays. In the fall of 2014, Arlington, Virginia launched a new commute planning site for the Washington, DC metropolitan area, depending on OpenTripPlanner to weigh the costs and benefits of various travel options. In 2015 the New York State department of transportation's 511 transit trip planner began using OTP to provide itineraries for public transit systems throughout the state from a single unified OTP instance. After seven years of hard work and almost 10,000 commits from over 100 contributors around the world, OTP version 1.0 was released on 9 September 2016. Starting in early 2016, the regional transport authorities of Helsinki, Finland (HSL) and Oslo, Norway (Ruter) began using a completely open source passenger information system based on OpenTripPlanner. National-scale OpenTripPlanner instances are also maintained in Finland and Norway.","title":"OpenTripPlanner Project History"},{"location":"Intermediate-Tutorial/","text":"Intermediate Usage of OpenTripPlanner This page follows up on basic usage with more detailed examples of OpenTripPlanner functionality. It is not an exhaustive list but should serve to demonstrate some useful applications. Using the web API to plan a transit trip One of the most important ways that OpenTripPlanner is used is, of course, the planning of trips. You can use the API to request an itinerary from one place to another at a particular time: http://localhost:8080/otp/routers/default/plan?fromPlace=43.637,-79.434&toPlace=43.646,-79.388&time=1:02pm&date=11-14-2017&mode=TRANSIT,WALK&maxWalkDistance=500&arriveBy=false The above query makes a request to the locally running server http://localhost:8080/ , requesting the planner resource ...otp/routers/default/plan , and passes the following parameters: fromPlace=43.637,-79.434 , the origin of the trip, in latitude, longitude toPlace=43.646,-79.388 , the destination of the trip time=1:02pm , the desired departure time date= , the desired departure date arriveBy=false , specifies that the given time is when we plan to depart rather than when we want to arrive mode=TRANSIT,WALK , transport modes to consider, in this case a combination of walking and transit maxWalkDistance=500 , the maximum distance in meters that you are willing to walk If you run this query as is you will very likely get a response saying that a trip has not been found. Try changing the fromPlace, toPlace, time and date parameters to match the location and time period of the data you loaded when you initially built the graph. More (optional) parameters for the planner resource are documented here . Calculating travel time isochrones OpenTripPlanner can also be used to calculate the area which is accessible from a point within a given travel time, also known as a travel time isochrone. ( Image courtesy of marcusyoung ) Here we'll use of the LIsochrone resource in the following query: http://localhost:8080/otp/routers/ttc/isochrone?fromPlace=43.637,-79.434&mode=WALK,TRANSIT&date=11-14-2017&time=8:00am&maxWalkDistance=500&cutoffSec=1800&cutoffSec=3600 Many of the parameters in this GET request should be familiar from the last example, though a few new ones have been added. fromPlace=43.637,-79.434 is our origin location in latitude,longitude cutoffSec=1800 tells the router that we want an isochrone ending at a half hour (1800 seconds) travel from the origin cutoffSec=3600 the second (optional) specification of this parameter means that we'll get a second result, this time one hour (3600 seconds) from the origin cutoffSec=... this argument can be passed any number of times with diferent values. The result of the above query, if all goes well, is a geoJSON file with two multipolygons showing the area accessible within both one and one-half hour. Take a look at the LIsochrone resource page for additional options. Additional resources and documentation See the configuration page for configuration settings which effect either the router instance or the graph building process (e.g. fare settings, elevation models, request logging, transfer settings, etc.). It may also be helpful to try running the OTP .jar file with the --help option for a full list of command line parameters. Full documentation for the API is available here .","title":"Intermediate Tutorial"},{"location":"Intermediate-Tutorial/#intermediate-usage-of-opentripplanner","text":"This page follows up on basic usage with more detailed examples of OpenTripPlanner functionality. It is not an exhaustive list but should serve to demonstrate some useful applications.","title":"Intermediate Usage of OpenTripPlanner"},{"location":"Intermediate-Tutorial/#using-the-web-api-to-plan-a-transit-trip","text":"One of the most important ways that OpenTripPlanner is used is, of course, the planning of trips. You can use the API to request an itinerary from one place to another at a particular time: http://localhost:8080/otp/routers/default/plan?fromPlace=43.637,-79.434&toPlace=43.646,-79.388&time=1:02pm&date=11-14-2017&mode=TRANSIT,WALK&maxWalkDistance=500&arriveBy=false The above query makes a request to the locally running server http://localhost:8080/ , requesting the planner resource ...otp/routers/default/plan , and passes the following parameters: fromPlace=43.637,-79.434 , the origin of the trip, in latitude, longitude toPlace=43.646,-79.388 , the destination of the trip time=1:02pm , the desired departure time date= , the desired departure date arriveBy=false , specifies that the given time is when we plan to depart rather than when we want to arrive mode=TRANSIT,WALK , transport modes to consider, in this case a combination of walking and transit maxWalkDistance=500 , the maximum distance in meters that you are willing to walk If you run this query as is you will very likely get a response saying that a trip has not been found. Try changing the fromPlace, toPlace, time and date parameters to match the location and time period of the data you loaded when you initially built the graph. More (optional) parameters for the planner resource are documented here .","title":"Using the web API to plan a transit trip"},{"location":"Intermediate-Tutorial/#calculating-travel-time-isochrones","text":"OpenTripPlanner can also be used to calculate the area which is accessible from a point within a given travel time, also known as a travel time isochrone. ( Image courtesy of marcusyoung ) Here we'll use of the LIsochrone resource in the following query: http://localhost:8080/otp/routers/ttc/isochrone?fromPlace=43.637,-79.434&mode=WALK,TRANSIT&date=11-14-2017&time=8:00am&maxWalkDistance=500&cutoffSec=1800&cutoffSec=3600 Many of the parameters in this GET request should be familiar from the last example, though a few new ones have been added. fromPlace=43.637,-79.434 is our origin location in latitude,longitude cutoffSec=1800 tells the router that we want an isochrone ending at a half hour (1800 seconds) travel from the origin cutoffSec=3600 the second (optional) specification of this parameter means that we'll get a second result, this time one hour (3600 seconds) from the origin cutoffSec=... this argument can be passed any number of times with diferent values. The result of the above query, if all goes well, is a geoJSON file with two multipolygons showing the area accessible within both one and one-half hour. Take a look at the LIsochrone resource page for additional options.","title":"Calculating travel time isochrones"},{"location":"Intermediate-Tutorial/#additional-resources-and-documentation","text":"See the configuration page for configuration settings which effect either the router instance or the graph building process (e.g. fare settings, elevation models, request logging, transfer settings, etc.). It may also be helpful to try running the OTP .jar file with the --help option for a full list of command line parameters. Full documentation for the API is available here .","title":"Additional resources and documentation"},{"location":"Localization/","text":"Localization This page contains instructions for both developers and translators on how to make the OTP interface usable by people who speak different languages. Developers will need to take certain steps to mark translatable strings within the source code. Translators will need to edit specific files within the project to create or revise the translation for their language. In OTP we use gettext for localization, for the following reasons: Plural suport Context support Automatic extraction of translatable strings from source code Translator comments support Source references (we can see where each translated string is used in the source code) In the Javascript UI the i18next library is used. Three types of files are used in the OTP localization process: The .pot file is the message template. It is a starting point for creating new .po files. .po files are created and edited by translators based on the .pot file. .json files are generated from the .po files for each language. .js files are localization configuration files which specify units and time/date formats. Only the .po and .js files are directly edited. The .pot file is created from an automated analysis of annotated source code. The .json files are also automatically generated as an easy way for the Javascript UI to consume the contents of the .po files. All translation files are in the directory /src/client/i18n . For Software Developers: Adding New Strings When you add a string to Javascript source that will be seen by the end user, wherever that string is referenced you should surround it with a call to a special function. The name of the function depends on what kind of string it is: basic string: _tr('string', parameters) basic string with context: ngettext('context', 'string') string with plural: ngettext('singular', 'plural', quantity) string with plural and context: npgettext('context', 'singular', 'plural', quantity) For more detail, see Sprintf parameters . A \"context\" is any string (preferably short and without whitespace) that is used to disambiguate the translation of the main string. It is used when developers get input from translators that some string should be translated in different ways in different parts of the program. Each of those distinct places will be assigned a different context string. When you add strings to the source code, if you think that translators might not understand how the string is used or what parameters it requires, add translator comments like this: //TRANSLATORS: Start: location at [time date] (Used in print itinerary //when do you start your trip) html += '<h3>' + _tr ( 'Start: %s at %s' , this . getStartLocationStr (), this . getStartTimeStr ()) + '</h3>' ; Translator comments must always start with TRANSLATORS: and must be in the line immediately before translated string. Otherwise they won't be extracted together with the string. Examples: Basic translated string //TRANSLATORS: Board Public transit route name (agency name //Stop ID ) start time html += '<li><b>' + _tr ( 'Board' ) + '</b>: ' + leg . from . name + ' (' + leg . from . stopId . agencyId + ' Stop ID #' + //With named sprintf parameters (our preferred option) //TRANSLATORS: Start: location at [time date] (Used in print itinerary //when do you start your trip) html += '<h3>' + _tr ( 'Start: %(location)s at %(time_date)s' , { 'location' : this . getStartLocationStr (), 'time_date' : this . getStartTimeStr ()}) + '</h3>' ; //With positional sprintf parameters (to be avoided because word order changes between languages) html += '<h3>' + _tr ( 'End: %1$s at %2$s' , this . getEndLocationStr (), this . getEndTimeStr ()) + '</h3>' ; Normal string with context if ( leg . headsign ) html += pgettext ( \"bus_direction\" , \" to \" ) + leg . headsign ; //same string could be different translation //TRANSLATORS: [distance] to [name of destination] html += \" \" + otp . util . Itin . distanceString ( leg . distance ) + pgettext ( \"direction\" , \" to \" ) + leg . to . name ; Plural strings //TRANSLATORS: widget title this . setTitle ( ngettext ( \"%d Itinerary Returned\" , \"%d Itineraries Returned\" , this . itineraries . length )); If you add new strings to the source code, it is good practice to also update the translation template and the translations but it is not mandatory (these can be updated later). It is also recommended to include \"i18n string change\" in the commit message. Updating translations Translations are updated with the help of Babel and i18next-conv (xgettext doesn't yet have great Javascript support). Babel is used to extract strings from the Javascript source code into the shared .POT translation template, and also for updating the existing .PO language translations when new strings are introduced in the template. i18next-conv is used to convert the .PO translation files for the individual languages to .json files which are used by the Javascript translation library. Installing Babel You can install it from your operating system's package repository (if available) or you can use virtualenv . Install virtualenv (This depends on your operating system) Create virtualenv with name .venv in directory where src and other files resides (Root OpenTripPlanner directory). virtualenv2 .venv Use virtualenv source .venv/bin/activate Install babel pip install babel If you didn't install babel from virtualenv in root OpenTripPlanner directory you have to add path to babel in Makefile. change PYBABEL variable to path to pybabel. Installing i18next-conv i18next-conv requires nodejs . Once you have NodeJS installed, use npm install i18next-conv to install i18next-conv in the same directory where you created virtualenv. Updating the .pot Template In the root of the OTP repo, run make . The commands in the Makefile will extract the translatable strings from the Javascript files and update the translation template messages.pot , as well as the .po translation files for all the different languages. Once this is done, you can translate the new strings in the .po files. After saving the updated .po file, run make update_js to transform to PO files into .json , which is used at runtime by the Javascript translation library. After you rebuild OTP, all new strings should be visible in the UI. For Translators: Creating New Translations The following can get a bit technical. If you want to do a translation but don't want to / know how to install all this software, post to the opentripplanner-dev mailing list stating what language you want to translate, and someone will make you a corresponding .po file. Creating a New Translation File New .po files are created from the .pot template with the help of msginit , which is run like this: msginit init -l <LAN> -i messages.pot -o <LAN>.po , where <LAN> is a culture code. New .po files can also be created with the help of Poedit . All translation files should be placed in the directory /src/client/i18n . Please use the ISO language code as the culture code (e.g. fr.po for French). We will append country codes in the following limited circumstances: British versus US English ( en_GB.po and en_US.po ) Brazilian Portuguese pt_BR.po , as opposed to pt.po for European Portuguese Chinese: zh_TW.po for traditional characters as used in e.g. Taiwan and Hong Kong, and zh_CN.po for simplified characters as used in mainland China, Singapore, etc. These conventions are based on the Launchpad Translation page. In Linux you can see the culture codes for all the locales you have installed with the command locale -a . A list of culture codes is also availible here . Performing the Translation Configuration Copy the locale configuration script English.js from /src/client/js/otp/locale to YourLanguage.js and customize it to your language. Change the name, units, locale_short and datepicker_locale_short values. Translate infoWidgets and localize the time/date formats. Then take the following steps: Add the culture code to the LANGS variable in the Makefile` Add the new YourLanguage.js to the locales variable in /src/client/js/otp/config.js Add a new datepicker translation to /src/client/js/lib/jquery-ui/i18n Load the new datepicker translation and YourLanguage.js in /src/client/index.html Translating Strings For translating the strings themselves, you can use any program that supports gettext files. You can in theory use any text editor, but programs or plugins purpose-built for translating are recommended. Most of them support checking parameter correctness, translation memory, web translating services etc. to make the task easier. Here are some such programs (all free and open source): Poedit For Linux, Windows, and Mac. Use a version newer then 1.5. This is the recommended choice for getting started with localization. It supports translation memory and file context. Web Poedit Usable from within a web browser, you don't have to install or register Gted A plugin for the Eclipse IDE. Lokalize Runs under KDE on Linux, has some Windows support. Supports translation memory and file context. Virtaal For Linux, Windows, and beta for Mac. Supports Google and Microsoft web translation and other translation memory services. All these programs support setting a string to \"fuzzy\", marking that it needs review etc. in case you translate something but aren't sure of it's correctness. Sometimes those flags are set automatically if the original string was changed and translators must check if the translation is still correct. Caveats Be careful when translating that the translated strings have the same format as the original. If spaces appear at the start or end of the strings, they must also appear in the translation. The order of unnamed (positional) parameters may change depending on the target language. You can also leave parameter out of the translation if it is irrelevant in the target language.","title":"Localization"},{"location":"Localization/#localization","text":"This page contains instructions for both developers and translators on how to make the OTP interface usable by people who speak different languages. Developers will need to take certain steps to mark translatable strings within the source code. Translators will need to edit specific files within the project to create or revise the translation for their language. In OTP we use gettext for localization, for the following reasons: Plural suport Context support Automatic extraction of translatable strings from source code Translator comments support Source references (we can see where each translated string is used in the source code) In the Javascript UI the i18next library is used. Three types of files are used in the OTP localization process: The .pot file is the message template. It is a starting point for creating new .po files. .po files are created and edited by translators based on the .pot file. .json files are generated from the .po files for each language. .js files are localization configuration files which specify units and time/date formats. Only the .po and .js files are directly edited. The .pot file is created from an automated analysis of annotated source code. The .json files are also automatically generated as an easy way for the Javascript UI to consume the contents of the .po files. All translation files are in the directory /src/client/i18n .","title":"Localization"},{"location":"Localization/#for-software-developers-adding-new-strings","text":"When you add a string to Javascript source that will be seen by the end user, wherever that string is referenced you should surround it with a call to a special function. The name of the function depends on what kind of string it is: basic string: _tr('string', parameters) basic string with context: ngettext('context', 'string') string with plural: ngettext('singular', 'plural', quantity) string with plural and context: npgettext('context', 'singular', 'plural', quantity) For more detail, see Sprintf parameters . A \"context\" is any string (preferably short and without whitespace) that is used to disambiguate the translation of the main string. It is used when developers get input from translators that some string should be translated in different ways in different parts of the program. Each of those distinct places will be assigned a different context string. When you add strings to the source code, if you think that translators might not understand how the string is used or what parameters it requires, add translator comments like this: //TRANSLATORS: Start: location at [time date] (Used in print itinerary //when do you start your trip) html += '<h3>' + _tr ( 'Start: %s at %s' , this . getStartLocationStr (), this . getStartTimeStr ()) + '</h3>' ; Translator comments must always start with TRANSLATORS: and must be in the line immediately before translated string. Otherwise they won't be extracted together with the string.","title":"For Software Developers: Adding New Strings"},{"location":"Localization/#examples","text":"","title":"Examples:"},{"location":"Localization/#basic-translated-string","text":"//TRANSLATORS: Board Public transit route name (agency name //Stop ID ) start time html += '<li><b>' + _tr ( 'Board' ) + '</b>: ' + leg . from . name + ' (' + leg . from . stopId . agencyId + ' Stop ID #' + //With named sprintf parameters (our preferred option) //TRANSLATORS: Start: location at [time date] (Used in print itinerary //when do you start your trip) html += '<h3>' + _tr ( 'Start: %(location)s at %(time_date)s' , { 'location' : this . getStartLocationStr (), 'time_date' : this . getStartTimeStr ()}) + '</h3>' ; //With positional sprintf parameters (to be avoided because word order changes between languages) html += '<h3>' + _tr ( 'End: %1$s at %2$s' , this . getEndLocationStr (), this . getEndTimeStr ()) + '</h3>' ;","title":"Basic translated string"},{"location":"Localization/#normal-string-with-context","text":"if ( leg . headsign ) html += pgettext ( \"bus_direction\" , \" to \" ) + leg . headsign ; //same string could be different translation //TRANSLATORS: [distance] to [name of destination] html += \" \" + otp . util . Itin . distanceString ( leg . distance ) + pgettext ( \"direction\" , \" to \" ) + leg . to . name ;","title":"Normal string with context"},{"location":"Localization/#plural-strings","text":"//TRANSLATORS: widget title this . setTitle ( ngettext ( \"%d Itinerary Returned\" , \"%d Itineraries Returned\" , this . itineraries . length )); If you add new strings to the source code, it is good practice to also update the translation template and the translations but it is not mandatory (these can be updated later). It is also recommended to include \"i18n string change\" in the commit message.","title":"Plural strings"},{"location":"Localization/#updating-translations","text":"Translations are updated with the help of Babel and i18next-conv (xgettext doesn't yet have great Javascript support). Babel is used to extract strings from the Javascript source code into the shared .POT translation template, and also for updating the existing .PO language translations when new strings are introduced in the template. i18next-conv is used to convert the .PO translation files for the individual languages to .json files which are used by the Javascript translation library.","title":"Updating translations"},{"location":"Localization/#installing-babel","text":"You can install it from your operating system's package repository (if available) or you can use virtualenv . Install virtualenv (This depends on your operating system) Create virtualenv with name .venv in directory where src and other files resides (Root OpenTripPlanner directory). virtualenv2 .venv Use virtualenv source .venv/bin/activate Install babel pip install babel If you didn't install babel from virtualenv in root OpenTripPlanner directory you have to add path to babel in Makefile. change PYBABEL variable to path to pybabel.","title":"Installing Babel"},{"location":"Localization/#installing-i18next-conv","text":"i18next-conv requires nodejs . Once you have NodeJS installed, use npm install i18next-conv to install i18next-conv in the same directory where you created virtualenv.","title":"Installing i18next-conv"},{"location":"Localization/#updating-the-pot-template","text":"In the root of the OTP repo, run make . The commands in the Makefile will extract the translatable strings from the Javascript files and update the translation template messages.pot , as well as the .po translation files for all the different languages. Once this is done, you can translate the new strings in the .po files. After saving the updated .po file, run make update_js to transform to PO files into .json , which is used at runtime by the Javascript translation library. After you rebuild OTP, all new strings should be visible in the UI.","title":"Updating the .pot Template"},{"location":"Localization/#for-translators-creating-new-translations","text":"The following can get a bit technical. If you want to do a translation but don't want to / know how to install all this software, post to the opentripplanner-dev mailing list stating what language you want to translate, and someone will make you a corresponding .po file.","title":"For Translators: Creating New Translations"},{"location":"Localization/#creating-a-new-translation-file","text":"New .po files are created from the .pot template with the help of msginit , which is run like this: msginit init -l <LAN> -i messages.pot -o <LAN>.po , where <LAN> is a culture code. New .po files can also be created with the help of Poedit . All translation files should be placed in the directory /src/client/i18n . Please use the ISO language code as the culture code (e.g. fr.po for French). We will append country codes in the following limited circumstances: British versus US English ( en_GB.po and en_US.po ) Brazilian Portuguese pt_BR.po , as opposed to pt.po for European Portuguese Chinese: zh_TW.po for traditional characters as used in e.g. Taiwan and Hong Kong, and zh_CN.po for simplified characters as used in mainland China, Singapore, etc. These conventions are based on the Launchpad Translation page. In Linux you can see the culture codes for all the locales you have installed with the command locale -a . A list of culture codes is also availible here .","title":"Creating a New Translation File"},{"location":"Localization/#performing-the-translation","text":"","title":"Performing the Translation"},{"location":"Localization/#configuration","text":"Copy the locale configuration script English.js from /src/client/js/otp/locale to YourLanguage.js and customize it to your language. Change the name, units, locale_short and datepicker_locale_short values. Translate infoWidgets and localize the time/date formats. Then take the following steps: Add the culture code to the LANGS variable in the Makefile` Add the new YourLanguage.js to the locales variable in /src/client/js/otp/config.js Add a new datepicker translation to /src/client/js/lib/jquery-ui/i18n Load the new datepicker translation and YourLanguage.js in /src/client/index.html","title":"Configuration"},{"location":"Localization/#translating-strings","text":"For translating the strings themselves, you can use any program that supports gettext files. You can in theory use any text editor, but programs or plugins purpose-built for translating are recommended. Most of them support checking parameter correctness, translation memory, web translating services etc. to make the task easier. Here are some such programs (all free and open source): Poedit For Linux, Windows, and Mac. Use a version newer then 1.5. This is the recommended choice for getting started with localization. It supports translation memory and file context. Web Poedit Usable from within a web browser, you don't have to install or register Gted A plugin for the Eclipse IDE. Lokalize Runs under KDE on Linux, has some Windows support. Supports translation memory and file context. Virtaal For Linux, Windows, and beta for Mac. Supports Google and Microsoft web translation and other translation memory services. All these programs support setting a string to \"fuzzy\", marking that it needs review etc. in case you translate something but aren't sure of it's correctness. Sometimes those flags are set automatically if the original string was changed and translators must check if the translation is still correct.","title":"Translating Strings"},{"location":"Localization/#caveats","text":"Be careful when translating that the translated strings have the same format as the original. If spaces appear at the start or end of the strings, they must also appear in the translation. The order of unnamed (positional) parameters may change depending on the target language. You can also leave parameter out of the translation if it is irrelevant in the target language.","title":"Caveats"},{"location":"Scripting/","text":"Scripting Introduction The aim of OTP scripting is to be able to use and automate OTP from within scripts. The available languages right now are Jython and Groovy ; Jython being the most tested and supported. All the examples in this page are using Python. OTP Scripting could easily support in the future any other language that supports BSF (Bean Scripting Framework), such as Javascript or Ruby . Note : Jython is a Python-flavor using a Java JVM as runtime. Python and Jython are mostly compatible. Usage There are currently 3 different modes for using scripting: Launching OTP with the --script command-line parameter, providing the script filename as an option. Starting an OTP server with the --enableScriptingWebService command-line parameter, and posting a script to execute to the /ws/scripting/run API end-point. Launching a Jython script with otp-x.y.z-shaded.jar in the classpath and creating the scripting entry-point bean in the script itself. Launching a script from OTP The main advantage of this method is its simplicity. The drawback is that you need to start OTP everytime you run a script, which can be slow to startup for large graphs. The second drawback is that you can't import custom packages from within the script, you are limited to the \"plain basic\" Jython. Note : The Jython (or Groovy) JAR are not included in the OTP shaded JAR. You thus have to add one of them (depending on your script) to the java classpath (see command below). Jython jar can be downloaded here . Make sure you select the \"standalone\" version of jython, otherwise some classes will be missing. Note : Due a guava bug, there is an incompatibility between Jython 2.3 / 2.5 and OTP. To solve it, make sure otp.jar is added before jython-standalone.jar in the classpath. This bug should be solved in jython starting 2.7. Start OTP specifying the classpath and adding the --script option: $ java -cp otp-x.y.z-shaded.jar:jython-standalone.jar org.opentripplanner.standalone.OTPMain --graphs . --script myscript.py This will start OTP with a default graph in the current directory and execute the script myscript.py . The return value of the script is discarded and printed to the log as a warning if the return value is not null . Scripting web-service The main advantage of this method is that you do not need to start a new OTP server (which can take some time for large graphs) each time you start a new script. This mode is well-adapted for script development and debugging. The drawback is about security: it is not advisable to use this method for public-facing servers. Start an OTP server as usual, adding the --enableScriptingWebService option: $ java -cp otp-x.y.z-shaded.jar:jython-standalone.jar org.opentripplanner.standalone.OTPMain --graphs . --server --enableScriptingWebService The API end-point /ws/scripting/run now accepts script content to be run, posted as multi-part form data. To post a script to be executed, you can use either: The online form at http://host:8080/scripting.html , where you can upload a localfile to the server; Using curl from the command-line, such as: $ curl --form \"scriptfile=@myscript.py\" host:8080/otp/scripting/run The return value of the script is passed as the return value of the web-service, in textual form. This can be used to return some value to the client (for example data in CSV form). The standard output / error streams of the script (the place where the various print statements are printed) is the standard output of the OTP server (the console where you start the OTP server). The default location where files are loaded or saved is the working directory of the server, usually the directory from where you started the OTP server. Warning : Enable this web-service on public-facing server is rather dangerous as this will open a whole range of exploits on the application. Using OTP as a library The advantage of this method is its versatility. You can import any custom library in your script, and you are free to create the OTP server instance when you need it. The drawback is that you need to have an external Jython interpreter installed, and you need to startup OTP yourself within the script (2 lines of code, see below). Example of use using python: #!/usr/bin/jython from org.opentripplanner.scripting.api import * otp = OtpsEntryPoint . fromArgs ([ \"--graphs\" , \"/path/to/graphs\" , \"--router\" , \"amsterdam\" ]) # ... the rest of your script goes here ... $ java -cp otp-x.y.z-shaded.jar:jython-standalone.jar org.python.util.jython myscript.py Or, simpler: $ jython -Dpython.path = otp-x.y.z-shaded.jar myscript.py Note that contrary to java custom the jython \"main\" class is all lowercase, this is not a typo. Script tutorial For a simple but functional example, please see this script . With the embedded comments it should be self-explanatory. In order to use this demo in the \"library\" mode, insert the 3 python lines given in the previous section at the beginning of the script. API For a complete documentation, please see the online JavaDoc of all classes within the org.opentripplanner.scripting.api package. Classes in this package are meant to be kept stable in time, at least regarding backward compatibility. Be careful as scripting is still in development phase; so there is no strong guarantee about the stability of the API, which is only a stated long-term goal. The aim is to achieve a stable API for the 1.0 OTP release.","title":"Scripting"},{"location":"Scripting/#scripting","text":"","title":"Scripting"},{"location":"Scripting/#introduction","text":"The aim of OTP scripting is to be able to use and automate OTP from within scripts. The available languages right now are Jython and Groovy ; Jython being the most tested and supported. All the examples in this page are using Python. OTP Scripting could easily support in the future any other language that supports BSF (Bean Scripting Framework), such as Javascript or Ruby . Note : Jython is a Python-flavor using a Java JVM as runtime. Python and Jython are mostly compatible.","title":"Introduction"},{"location":"Scripting/#usage","text":"There are currently 3 different modes for using scripting: Launching OTP with the --script command-line parameter, providing the script filename as an option. Starting an OTP server with the --enableScriptingWebService command-line parameter, and posting a script to execute to the /ws/scripting/run API end-point. Launching a Jython script with otp-x.y.z-shaded.jar in the classpath and creating the scripting entry-point bean in the script itself.","title":"Usage"},{"location":"Scripting/#launching-a-script-from-otp","text":"The main advantage of this method is its simplicity. The drawback is that you need to start OTP everytime you run a script, which can be slow to startup for large graphs. The second drawback is that you can't import custom packages from within the script, you are limited to the \"plain basic\" Jython. Note : The Jython (or Groovy) JAR are not included in the OTP shaded JAR. You thus have to add one of them (depending on your script) to the java classpath (see command below). Jython jar can be downloaded here . Make sure you select the \"standalone\" version of jython, otherwise some classes will be missing. Note : Due a guava bug, there is an incompatibility between Jython 2.3 / 2.5 and OTP. To solve it, make sure otp.jar is added before jython-standalone.jar in the classpath. This bug should be solved in jython starting 2.7. Start OTP specifying the classpath and adding the --script option: $ java -cp otp-x.y.z-shaded.jar:jython-standalone.jar org.opentripplanner.standalone.OTPMain --graphs . --script myscript.py This will start OTP with a default graph in the current directory and execute the script myscript.py . The return value of the script is discarded and printed to the log as a warning if the return value is not null .","title":"Launching a script from OTP"},{"location":"Scripting/#scripting-web-service","text":"The main advantage of this method is that you do not need to start a new OTP server (which can take some time for large graphs) each time you start a new script. This mode is well-adapted for script development and debugging. The drawback is about security: it is not advisable to use this method for public-facing servers. Start an OTP server as usual, adding the --enableScriptingWebService option: $ java -cp otp-x.y.z-shaded.jar:jython-standalone.jar org.opentripplanner.standalone.OTPMain --graphs . --server --enableScriptingWebService The API end-point /ws/scripting/run now accepts script content to be run, posted as multi-part form data. To post a script to be executed, you can use either: The online form at http://host:8080/scripting.html , where you can upload a localfile to the server; Using curl from the command-line, such as: $ curl --form \"scriptfile=@myscript.py\" host:8080/otp/scripting/run The return value of the script is passed as the return value of the web-service, in textual form. This can be used to return some value to the client (for example data in CSV form). The standard output / error streams of the script (the place where the various print statements are printed) is the standard output of the OTP server (the console where you start the OTP server). The default location where files are loaded or saved is the working directory of the server, usually the directory from where you started the OTP server. Warning : Enable this web-service on public-facing server is rather dangerous as this will open a whole range of exploits on the application.","title":"Scripting web-service"},{"location":"Scripting/#using-otp-as-a-library","text":"The advantage of this method is its versatility. You can import any custom library in your script, and you are free to create the OTP server instance when you need it. The drawback is that you need to have an external Jython interpreter installed, and you need to startup OTP yourself within the script (2 lines of code, see below). Example of use using python: #!/usr/bin/jython from org.opentripplanner.scripting.api import * otp = OtpsEntryPoint . fromArgs ([ \"--graphs\" , \"/path/to/graphs\" , \"--router\" , \"amsterdam\" ]) # ... the rest of your script goes here ... $ java -cp otp-x.y.z-shaded.jar:jython-standalone.jar org.python.util.jython myscript.py Or, simpler: $ jython -Dpython.path = otp-x.y.z-shaded.jar myscript.py Note that contrary to java custom the jython \"main\" class is all lowercase, this is not a typo.","title":"Using OTP as a library"},{"location":"Scripting/#script-tutorial","text":"For a simple but functional example, please see this script . With the embedded comments it should be self-explanatory. In order to use this demo in the \"library\" mode, insert the 3 python lines given in the previous section at the beginning of the script.","title":"Script tutorial"},{"location":"Scripting/#api","text":"For a complete documentation, please see the online JavaDoc of all classes within the org.opentripplanner.scripting.api package. Classes in this package are meant to be kept stable in time, at least regarding backward compatibility. Be careful as scripting is still in development phase; so there is no strong guarantee about the stability of the API, which is only a stated long-term goal. The aim is to achieve a stable API for the 1.0 OTP release.","title":"API"},{"location":"Security/","text":"Security OpenTripPlanner has some web API methods that are potentially dangerous. For example, it is possible to instruct the OTP server to reload all graphs, or even to load data off the wire as a graph. Access to these methods should clearly be restricted. Out of the box, OTP is configured to only allow access to these sensitive API methods when the caller has authenticated with a username and password via HTTP Basic authentication, and to only allow Basic authentication over a secure connection. While basic authentication sends the credentials as clear text and is therefore completely insecure when used alone, it is quite safe when used over a secure channel like SSL/TLS that encrypts all communication. Therefore, if you wish to access these sensitive methods OTP must be running on a server that supports HTTPS, or authentication must be disabled entirely. OTP's built-in Grizzly server is configured to accept HTTPS connections on port 8081 by default, but the HTTPS listener needs an encryption key to establish a connection. The key is placed in a \"keystore\", a format specific to Java server environments. Creating a keystore By default, OTP will look for the keystore at /var/otp/keystore . To generate a self-signed key for testing, use the command: keytool -genkey -keystore /var/otp/keystore -alias OTPServerKey The alias of the key is arbitrary, but it's best to supply one that indicates the purpose of the key to override the default. keytool will ask you a series of questions about you and your organization; again, any values will do when creating this self-signed test key. keytool will also ask you for a password to protect your keystore and key. This password will eventually be configurable, but for now it is hard-coded into the OTP server, so you must set the keystore and key passwords both to opentrip . Of course with a self-signed key, most clients will (rightfully) refuse to connect without special permission from the user. You'll need to add a security exception to most web browsers, or add the --insecure switch when using CURL. You could theoretically buy and install a \"real\" trusted SSL/TLS certificate it in the keystore using keytool -gencert , but since none of the functionality protected by this encryption is public-facing a self-signed key should be sufficient for most use cases. All connections to these API methods should be from trusted parties who can verify the validity of the key with you directly as needed. Testing Once you have created a key, start up the OTP server and test that HTTPS access and authentication are possible. The following command should trigger a reload of all graphs: curl -v --insecure -X PUT --user ROUTERS:ultra_secret -H \"accept: application/json\" \"https://localhost:8081/otp/routers\" The username and password ( ROUTERS:ultra_secret ) are placeholders hard-coded into OTP. They will be configurable in version 1.0. You should also be able to fetch any other OTP resources over HTTPS. For example, you could open a raw TLS connection using openssl s_client -connect localhost:8081 , then issue the request GET index.html HTTP/1.1 . Turning off security The other alternative is to place OTP behind a firewall, reverse proxy, etc. which will prevent access to dangerous API methods from untrusted networks, then turn off authentication entirely. This will allow you to sidestep the need for SSL/TLS certificates and authentication, but should be done with caution and careful planning. If you are sure you want to disable authentication, simply add the --insecure switch when starting up OTP the Grizzly server. CORS TODO explain this","title":"Security"},{"location":"Security/#security","text":"OpenTripPlanner has some web API methods that are potentially dangerous. For example, it is possible to instruct the OTP server to reload all graphs, or even to load data off the wire as a graph. Access to these methods should clearly be restricted. Out of the box, OTP is configured to only allow access to these sensitive API methods when the caller has authenticated with a username and password via HTTP Basic authentication, and to only allow Basic authentication over a secure connection. While basic authentication sends the credentials as clear text and is therefore completely insecure when used alone, it is quite safe when used over a secure channel like SSL/TLS that encrypts all communication. Therefore, if you wish to access these sensitive methods OTP must be running on a server that supports HTTPS, or authentication must be disabled entirely. OTP's built-in Grizzly server is configured to accept HTTPS connections on port 8081 by default, but the HTTPS listener needs an encryption key to establish a connection. The key is placed in a \"keystore\", a format specific to Java server environments.","title":"Security"},{"location":"Security/#creating-a-keystore","text":"By default, OTP will look for the keystore at /var/otp/keystore . To generate a self-signed key for testing, use the command: keytool -genkey -keystore /var/otp/keystore -alias OTPServerKey The alias of the key is arbitrary, but it's best to supply one that indicates the purpose of the key to override the default. keytool will ask you a series of questions about you and your organization; again, any values will do when creating this self-signed test key. keytool will also ask you for a password to protect your keystore and key. This password will eventually be configurable, but for now it is hard-coded into the OTP server, so you must set the keystore and key passwords both to opentrip . Of course with a self-signed key, most clients will (rightfully) refuse to connect without special permission from the user. You'll need to add a security exception to most web browsers, or add the --insecure switch when using CURL. You could theoretically buy and install a \"real\" trusted SSL/TLS certificate it in the keystore using keytool -gencert , but since none of the functionality protected by this encryption is public-facing a self-signed key should be sufficient for most use cases. All connections to these API methods should be from trusted parties who can verify the validity of the key with you directly as needed.","title":"Creating a keystore"},{"location":"Security/#testing","text":"Once you have created a key, start up the OTP server and test that HTTPS access and authentication are possible. The following command should trigger a reload of all graphs: curl -v --insecure -X PUT --user ROUTERS:ultra_secret -H \"accept: application/json\" \"https://localhost:8081/otp/routers\" The username and password ( ROUTERS:ultra_secret ) are placeholders hard-coded into OTP. They will be configurable in version 1.0. You should also be able to fetch any other OTP resources over HTTPS. For example, you could open a raw TLS connection using openssl s_client -connect localhost:8081 , then issue the request GET index.html HTTP/1.1 .","title":"Testing"},{"location":"Security/#turning-off-security","text":"The other alternative is to place OTP behind a firewall, reverse proxy, etc. which will prevent access to dangerous API methods from untrusted networks, then turn off authentication entirely. This will allow you to sidestep the need for SSL/TLS certificates and authentication, but should be done with caution and careful planning. If you are sure you want to disable authentication, simply add the --insecure switch when starting up OTP the Grizzly server.","title":"Turning off security"},{"location":"Security/#cors","text":"TODO explain this","title":"CORS"},{"location":"Surface/","text":"One-to-many Travel Time Analysis This page covers one way to use OTP for one-to-many travel time analysis. Note that this page describes APIs that have been mostly undocumented, unsupported, and unmaintained for several years. They were created as a minimum viable prototype framework for cumulative opportunities accessibility calculations, which informed subsequent work on the R5 and Conveyal Analysis projects. As niche tools the latter do not have the same level of community activity as OTP, but represent a much more specialized descendant of the analysis functionality described here. Unlike OTP, they handle variability in travel time across a window of departure times, uncertainty in travel time for routes in scenarios defined in terms of headways, lightweight on-the-fly application of scenarios modifying the transit network, and a novel percentile-based definition of accessibility that is robust against outliers and partially unreachable destinations. That said, a lot of people like to use OTP for more straightforward travel time and accessibility analysis, and this page is provided to serve as a starting point. Rationale If you're calculating travel times from one or more origin points to a large set of destination points, you probably don't want to use OTP's default routing API for passenger-facing journey planning. There are two main reasons for this. First, by default OTP does not optimize on travel time, it optimizes \"generalized cost\" including a lot of factors that have been introduced over time to reflect rider preferences. If changes to transportation services happen to open up new possibilities that are easier or more pleasant for the rider but slower, those slower travel times will be reported. This is then perceived as a confusing \"decrease\" in service quality due to added service. Second, finding paths between each origin/destination pair separately is extremely inefficient. If you need paths to more than one destination from each origin, it is generally preferable to find all those paths with a single search. It is possible to find paths from one origin to thousands or even millions of destinations in about the same amount of time it takes to find paths from one origin to one destination. Exploiting this one fact can easily reduce total computation time by orders of magnitude. Note that the features described below are present in OTP 1.x, but have been removed from OTP 2.x. There are currently no plans to support analysis use cases in OTP 2, but OTP1 should remain usable for this purpose for people who wish to do so. Travel Time Surface / PointSet APIs Definitions: A PointSet is a set of geographic locations that could serve as the origins or destinations of a batch of trip planning operations. They may have quantities of \"opportunities\" attached to them (such as jobs, square meters of retail space, hospital beds, etc.) which can be summed to yield cumulative opportunities accessibility metrics. The term Surface is used here in the sense of a function from a 2D location to a quantity. For any origin point we can produce a travel time surface, i.e. a travel time to every geographic coordinate that can be reached from that origin. Once created, such a surface may be evaluated at every destination in a PointSet at once, incurring minimal additional computational cost. Because these APIs are not actively maintained and have the potential to cache large amounts of data in memory, they are disabled by default. You have to enable them with additional command line options when starting OTP. They are not intended for use in production on public servers. They were created for local research use, as a minimum viable prototype of this conceptual framework. Although the PointSet class could certainly be initialized and used differently within Java code, for the purposes of these HTTP APIs they are always loaded from CSV or GeoJSON files in a directory specified on the command line. Example PointSets can be loaded from CSV files, with one point defined on each row. The file should be in UTF-8 encoding and have a header row giving the column names. At least one column should be called \"lat\" (or \"latitude\") and at least one should be called \"lon\" (or \"longitude\"). These specify a location for each point as floating point numbers in the WGS84 coordinate system. The other columns define the magnitude of opportunities reachable at each point (e.g. jobs or square meters of retail space). These should always be integers. You can always set the magnitude to 1 if you're only interested in the travel time or quantity of points reached. Colons can be used in the magnitude column names to group them into categories. Here is a short example defining two points (perhaps representing buildings or small census units) with associated numbers of jobs in two categories: lat,lon,jobs:total,jobs:retail,jobs:manufacturing,population:total 45.0,33.3,100,40,60,30 45.1,33.0, 20,15,5,40 As mentioned above it is also possible to load PointSets from GeoJSON. Examples of the CSV, GeoJSON, and Shapefile formats for PointSets can be found at https://github.com/opentripplanner/OpenTripPlanner/tree/master/src/test/resources/pointset If you want to try out the synthetic data in that directory for Austin, Texas, you can find OSM data at https://www.nextzen.org/metro-extracts/index.html#austin_texas and GTFS data at https://transit.land/feed-registry/operators/o-9v6-capitalmetro If you had a directory tree rooted at ~/otp with subdirectory ~/otp/graphs/austin containing an OSM PBF file for the streets and a GTFS ZIP file with transit data, and another subdirectory ~/otp/pointsets containing a PointSet CSV file named destinations.csv , you could perform accessibility calculations as follows: First, build an OpenTripPlanner graph from the OSM and GTFS inputs: java -Xmx4G -jar otp-1.4.0-shaded.jar --build ~/otp/graphs/austin Then start the OpenTripPlanner server: java -Xmx4G -jar otp-1.4.0-shaded.jar --graphs ~/otp/graphs --router austin --server --analyst --pointSets ~/otp/pointsets The OpenTripPlanner server should then be available at http://localhost:8080/index.html. The --analyst switch enables the HTTP endpoints that calculate travel time surfaces, and the --pointSet parameter tells OTP where to look to load any pointsets referenced in those API requests. The contents of the PointSets should then be visible at: http://localhost:8080/otp/pointsets/destinations You can then create a travel time surface by hitting /otp/surfaces with a POST request, using query parameters similar to those in a normal OTP trip planning API request: `curl -X POST \"http://localhost:8080/otp/surfaces?batch=true&fromPlace=30.285159872426014%2C-97.7467346191406&time=5%3A46pm&date=07-31-2020&mode=TRANSIT%2CWALK&maxWalkDistance=800&arriveBy=false\" Note the batch=true parameter. This is important to tell OTP not to validate the toPlace parameter, which we're leaving out to build paths to all destinations from one origin. If the request is successful, the server should respond with a JSON representation of a single travel time surface record, something like: {\"id\":0,\"params\":{\"date\":\"07-31-2020\",\"mode\":\"TRANSIT,WALK\",\"arriveBy\":\"false\",\"fromPlace\":\"30.285159872426014,-97.7467346191406\",\"batch\":\"true\",\"time\":\"5:46pm\",\"maxWalkDistance\":\"800\"}} This same record can now be seen at http://localhost:8080/otp/surfaces which lists all recently created travel time surfaces. Now that we have a surface and know its ID from the JSON (in this case 0), we can evaluate that surface at a set of points, like so: http://localhost:8080/otp/surfaces/0/indicator?targets=destinations That loads the pointset from destinations.csv and finds the travel time to each point in it, then aggregates the results into an accessibility indicator (hence the endpoint name \"indicator\"). The \"data\" property of the JSON response contains, for each column present in the pointset, an array of \"sums\" and \"counts\". The counts array represents the number of points reached at each minute of travel time from the origin. The \"sums\" array sums up the magnitudes of the points reached within each minute. Summing the values in the array from 0 to N then gives a cumulative opportunities accessibility indicator for N minutes of travel. If you add the query parameter detail=true , the response will also contain individual travel times to every destinations point in the PointSet. These indicator calls could in principle be combined with the one creating the travel time surface, eliminating the need to retain the surface on the server and make a seconds call. But retaining the surface is particularly useful for interactively generating multiple isochrones or rendering tiles, where someone might want to scroll around and zoom in generating thousands of images from the same surface. There are other endpoints for those purposes. Client Code The API endpoints described above are used when you switch to \"Analyst\" mode in the default OTP1 client at localhost:8080. You can use your browser's dev tools to observe the requests it sends, which render map tiles from the surface. Note that the tile requests are currently a bit strange: the UI is redundantly sending the full routing query string with every request, a vestige of the older system that did not assign IDs to cached travel time surfaces and instead looked them up based on the request parameters. Relevant Java Classes Though it is perhaps not ideal, the best way to understand this aspect of OTP is probably to dig through source code. Throughout its history OTP has been heavily used by people who worked directly with the source code, and documentation has not always kept pace with more experimental parts of the system, though there is a decent amount of commentary inline in the source code. Here are some classes that may serve as good starting points: org.opentripplanner.analyst.PointSet org.opentripplanner.analyst.SurfaceCache The cache of travel time surfaces is defined at org.opentripplanner.analyst.SurfaceCache and is currently hard-wired to hold on to the last 100 surfaces generated. Please don't read too much into these \"design decisions\" resulting in a stateful API susceptible to memory exhaustion. Again, this was created as a minimum viable prototype for use in local analysis work, and is not really suitable for a public-facing system. org.opentripplanner.api.resource.SurfaceResource Defines the HTTP API endpoints for working with PointSets and travel time surfaces. Whether or not you actually use this HTTP API, this class is important as the only example in the OTP codebase of how to construct a minimum-travel-time surface and bulk-evaluate it at a large number of destinations. These patterns of Java code could be adapted in your own methods, or perhaps integrated with the scripting API. Once a surface exists, you can also make isochrones and web Mercator map tiles of the travel time surface for display. org.opentripplanner.analyst.DiskBackedPointSetCache This loads the PointSets from disk and holds them in memory for use as destinations via the API. A request for the PointSet named \"schools\" will try to load it from the first file in the directory whose name begins with \"schools\" and ends with \".csv\" or \".json\". This defers to org.opentripplanner.analyst.PointSet#fromCsv and org.opentripplanner.analyst.PointSet#fromGeoJson to load files depending on the extension. (Note that there is also a PointSet#fromShapefile for Esri Shapefiles which is currently unused).","title":"One-to-many Travel Times"},{"location":"Surface/#one-to-many-travel-time-analysis","text":"This page covers one way to use OTP for one-to-many travel time analysis. Note that this page describes APIs that have been mostly undocumented, unsupported, and unmaintained for several years. They were created as a minimum viable prototype framework for cumulative opportunities accessibility calculations, which informed subsequent work on the R5 and Conveyal Analysis projects. As niche tools the latter do not have the same level of community activity as OTP, but represent a much more specialized descendant of the analysis functionality described here. Unlike OTP, they handle variability in travel time across a window of departure times, uncertainty in travel time for routes in scenarios defined in terms of headways, lightweight on-the-fly application of scenarios modifying the transit network, and a novel percentile-based definition of accessibility that is robust against outliers and partially unreachable destinations. That said, a lot of people like to use OTP for more straightforward travel time and accessibility analysis, and this page is provided to serve as a starting point.","title":"One-to-many Travel Time Analysis"},{"location":"Surface/#rationale","text":"If you're calculating travel times from one or more origin points to a large set of destination points, you probably don't want to use OTP's default routing API for passenger-facing journey planning. There are two main reasons for this. First, by default OTP does not optimize on travel time, it optimizes \"generalized cost\" including a lot of factors that have been introduced over time to reflect rider preferences. If changes to transportation services happen to open up new possibilities that are easier or more pleasant for the rider but slower, those slower travel times will be reported. This is then perceived as a confusing \"decrease\" in service quality due to added service. Second, finding paths between each origin/destination pair separately is extremely inefficient. If you need paths to more than one destination from each origin, it is generally preferable to find all those paths with a single search. It is possible to find paths from one origin to thousands or even millions of destinations in about the same amount of time it takes to find paths from one origin to one destination. Exploiting this one fact can easily reduce total computation time by orders of magnitude. Note that the features described below are present in OTP 1.x, but have been removed from OTP 2.x. There are currently no plans to support analysis use cases in OTP 2, but OTP1 should remain usable for this purpose for people who wish to do so.","title":"Rationale"},{"location":"Surface/#travel-time-surface-pointset-apis","text":"Definitions: A PointSet is a set of geographic locations that could serve as the origins or destinations of a batch of trip planning operations. They may have quantities of \"opportunities\" attached to them (such as jobs, square meters of retail space, hospital beds, etc.) which can be summed to yield cumulative opportunities accessibility metrics. The term Surface is used here in the sense of a function from a 2D location to a quantity. For any origin point we can produce a travel time surface, i.e. a travel time to every geographic coordinate that can be reached from that origin. Once created, such a surface may be evaluated at every destination in a PointSet at once, incurring minimal additional computational cost. Because these APIs are not actively maintained and have the potential to cache large amounts of data in memory, they are disabled by default. You have to enable them with additional command line options when starting OTP. They are not intended for use in production on public servers. They were created for local research use, as a minimum viable prototype of this conceptual framework. Although the PointSet class could certainly be initialized and used differently within Java code, for the purposes of these HTTP APIs they are always loaded from CSV or GeoJSON files in a directory specified on the command line.","title":"Travel Time Surface / PointSet APIs"},{"location":"Surface/#example","text":"PointSets can be loaded from CSV files, with one point defined on each row. The file should be in UTF-8 encoding and have a header row giving the column names. At least one column should be called \"lat\" (or \"latitude\") and at least one should be called \"lon\" (or \"longitude\"). These specify a location for each point as floating point numbers in the WGS84 coordinate system. The other columns define the magnitude of opportunities reachable at each point (e.g. jobs or square meters of retail space). These should always be integers. You can always set the magnitude to 1 if you're only interested in the travel time or quantity of points reached. Colons can be used in the magnitude column names to group them into categories. Here is a short example defining two points (perhaps representing buildings or small census units) with associated numbers of jobs in two categories: lat,lon,jobs:total,jobs:retail,jobs:manufacturing,population:total 45.0,33.3,100,40,60,30 45.1,33.0, 20,15,5,40 As mentioned above it is also possible to load PointSets from GeoJSON. Examples of the CSV, GeoJSON, and Shapefile formats for PointSets can be found at https://github.com/opentripplanner/OpenTripPlanner/tree/master/src/test/resources/pointset If you want to try out the synthetic data in that directory for Austin, Texas, you can find OSM data at https://www.nextzen.org/metro-extracts/index.html#austin_texas and GTFS data at https://transit.land/feed-registry/operators/o-9v6-capitalmetro If you had a directory tree rooted at ~/otp with subdirectory ~/otp/graphs/austin containing an OSM PBF file for the streets and a GTFS ZIP file with transit data, and another subdirectory ~/otp/pointsets containing a PointSet CSV file named destinations.csv , you could perform accessibility calculations as follows: First, build an OpenTripPlanner graph from the OSM and GTFS inputs: java -Xmx4G -jar otp-1.4.0-shaded.jar --build ~/otp/graphs/austin Then start the OpenTripPlanner server: java -Xmx4G -jar otp-1.4.0-shaded.jar --graphs ~/otp/graphs --router austin --server --analyst --pointSets ~/otp/pointsets The OpenTripPlanner server should then be available at http://localhost:8080/index.html. The --analyst switch enables the HTTP endpoints that calculate travel time surfaces, and the --pointSet parameter tells OTP where to look to load any pointsets referenced in those API requests. The contents of the PointSets should then be visible at: http://localhost:8080/otp/pointsets/destinations You can then create a travel time surface by hitting /otp/surfaces with a POST request, using query parameters similar to those in a normal OTP trip planning API request: `curl -X POST \"http://localhost:8080/otp/surfaces?batch=true&fromPlace=30.285159872426014%2C-97.7467346191406&time=5%3A46pm&date=07-31-2020&mode=TRANSIT%2CWALK&maxWalkDistance=800&arriveBy=false\" Note the batch=true parameter. This is important to tell OTP not to validate the toPlace parameter, which we're leaving out to build paths to all destinations from one origin. If the request is successful, the server should respond with a JSON representation of a single travel time surface record, something like: {\"id\":0,\"params\":{\"date\":\"07-31-2020\",\"mode\":\"TRANSIT,WALK\",\"arriveBy\":\"false\",\"fromPlace\":\"30.285159872426014,-97.7467346191406\",\"batch\":\"true\",\"time\":\"5:46pm\",\"maxWalkDistance\":\"800\"}} This same record can now be seen at http://localhost:8080/otp/surfaces which lists all recently created travel time surfaces. Now that we have a surface and know its ID from the JSON (in this case 0), we can evaluate that surface at a set of points, like so: http://localhost:8080/otp/surfaces/0/indicator?targets=destinations That loads the pointset from destinations.csv and finds the travel time to each point in it, then aggregates the results into an accessibility indicator (hence the endpoint name \"indicator\"). The \"data\" property of the JSON response contains, for each column present in the pointset, an array of \"sums\" and \"counts\". The counts array represents the number of points reached at each minute of travel time from the origin. The \"sums\" array sums up the magnitudes of the points reached within each minute. Summing the values in the array from 0 to N then gives a cumulative opportunities accessibility indicator for N minutes of travel. If you add the query parameter detail=true , the response will also contain individual travel times to every destinations point in the PointSet. These indicator calls could in principle be combined with the one creating the travel time surface, eliminating the need to retain the surface on the server and make a seconds call. But retaining the surface is particularly useful for interactively generating multiple isochrones or rendering tiles, where someone might want to scroll around and zoom in generating thousands of images from the same surface. There are other endpoints for those purposes.","title":"Example"},{"location":"Surface/#client-code","text":"The API endpoints described above are used when you switch to \"Analyst\" mode in the default OTP1 client at localhost:8080. You can use your browser's dev tools to observe the requests it sends, which render map tiles from the surface. Note that the tile requests are currently a bit strange: the UI is redundantly sending the full routing query string with every request, a vestige of the older system that did not assign IDs to cached travel time surfaces and instead looked them up based on the request parameters.","title":"Client Code"},{"location":"Surface/#relevant-java-classes","text":"Though it is perhaps not ideal, the best way to understand this aspect of OTP is probably to dig through source code. Throughout its history OTP has been heavily used by people who worked directly with the source code, and documentation has not always kept pace with more experimental parts of the system, though there is a decent amount of commentary inline in the source code. Here are some classes that may serve as good starting points: org.opentripplanner.analyst.PointSet org.opentripplanner.analyst.SurfaceCache The cache of travel time surfaces is defined at org.opentripplanner.analyst.SurfaceCache and is currently hard-wired to hold on to the last 100 surfaces generated. Please don't read too much into these \"design decisions\" resulting in a stateful API susceptible to memory exhaustion. Again, this was created as a minimum viable prototype for use in local analysis work, and is not really suitable for a public-facing system. org.opentripplanner.api.resource.SurfaceResource Defines the HTTP API endpoints for working with PointSets and travel time surfaces. Whether or not you actually use this HTTP API, this class is important as the only example in the OTP codebase of how to construct a minimum-travel-time surface and bulk-evaluate it at a large number of destinations. These patterns of Java code could be adapted in your own methods, or perhaps integrated with the scripting API. Once a surface exists, you can also make isochrones and web Mercator map tiles of the travel time surface for display. org.opentripplanner.analyst.DiskBackedPointSetCache This loads the PointSets from disk and holds them in memory for use as destinations via the API. A request for the PointSet named \"schools\" will try to load it from the first file in the directory whose name begins with \"schools\" and ends with \".csv\" or \".json\". This defers to org.opentripplanner.analyst.PointSet#fromCsv and org.opentripplanner.analyst.PointSet#fromGeoJson to load files depending on the extension. (Note that there is also a PointSet#fromShapefile for Esri Shapefiles which is currently unused).","title":"Relevant Java Classes"},{"location":"Troubleshooting-Routing/","text":"Troubleshooting Routing Graph Builder Annotations When you build a graph, OTP may encounter clearly incorrect or ambiguous data, or may detect less severe but potentially problematic situations in the input data. Most such problems result in a \"graph builder annotation\" being added to the graph. Many annotations are logged to the console while the graph, but some that might yield too many messages may be recorded as annotations without being logged. At the end of the graph build process, OTP prints a summary of all the annotations it added to the graph, like the following: 11:35:57.515 INFO (Graph.java:970) Summary (number of each type of annotation): 11:35:57.518 INFO (Graph.java:976) TurnRestrictionBad - 560 11:35:57.518 INFO (Graph.java:976) TurnRestrictionException - 15 11:35:57.518 INFO (Graph.java:976) StopLinkedTooFar - 22 11:35:57.518 INFO (Graph.java:976) HopSpeedSlow - 22 11:35:57.518 INFO (Graph.java:976) Graphwide - 1 11:35:57.518 INFO (Graph.java:976) GraphConnectivity - 407 11:35:57.519 INFO (Graph.java:976) ParkAndRideUnlinked - 1 11:35:57.519 INFO (Graph.java:976) StopNotLinkedForTransfers - 31 11:35:57.519 INFO (Graph.java:976) NoFutureDates - 1 The full set of annotations can be written out to an HTML report for closer inspection. To enable the creation of these (potentially voluminous) HTML reports, add \"htmlAnnotations\" : true to your graph builder JSON configuration. If the graph is saved to a file, these annotations are saved with it and can be examined later. Currently the only tool for doing this is the \"Graph Visualizer\", which is not particularly well maintained and is intended for use by software developers familiar with OTP who can patch up the code as needed. Debug layers OpenTripplanner has option to ease debugging problems with graph. Older option is graph visualizer. Which you can enable with --visualize parameter instead of --server when starting OTP. There you can see whole graph. You can click on edges and vertices and see the metadata. It is useful to see if street has expected options. And if connections are where they are expected. It can be hard to use on large graphs since, whole graph is displayed at once. And it can be hard to search for specific streets since only street graph is shown without the rest of information. Another option is to use debug layers, which shows extra layers on top of normal map. To enable them you need to add ?debug_layers=true to URL. For example http://localhost:8080/?debug_layers=true . This adds debug layers to layer choosing dialog. Currently you can choose between: Wheelchair access (which colors street edges red if they don't allow wheelchair or green otherwise) Bike Safety (colors street edges based on how good are for cycling [smaller is better]) Traversal permissions (colors street edges based on what types of transit modes are allowed to travel on them (Pedestrian, cycling, car are currently supported)) Traversal permissions layer also draws links from transit stops/bike rentals and P+R to graph. And also draws transit stops, bike rentals and P+R vertices with different color. Interpretation Traversal permissions layer A sample traversal permissions layer looks like the following * Yellow lines is the link between a stop and the street graph. * Grey lines are streets one can travel with the mode walk, bike, or car * Green lines are paths one can travel with the mode walk only * Red lines are streets one can travel with the mode car only * Grey dots vertices where edges are connected. If two edges are crossing w/o a vertice at the intersection point, users will not be able to go from one street to the other. But this can be valid in case of over/under pass for example. If it's an error, it's usually caused by improperly connected OSM data (a shared OSM node is required). OpenStreetMap Data Tags Affecting Permissions Access tags (such as bicycle/foot = yes/no/designated) can be used to override default graph-building parameters. As a default, foot and bicycle traffic is ''not'' allowed on highway=trunk , highway=trunk_link , highway=motorway , highway=motorway_link , or highway=construction . Both are allowed on highway=pedestrian , highway=cycleway , and highway=footway . Finally, bicycles are not allowed on highway=footway when any of the following tags appear on a footway: footway=sidewalk , public_transport=platform , or railway=platform . Other access tags (such as access=no and access=private affect routing as well, and can be overridden similarly. While access=no prohibits all traffic, access=private disallows through traffic. See osmWayPropertySet config attribute Railway Platforms OTP users in Helsinki have documented their best practices for coding railway platforms in OpenStreetMap. These guidelines are available in the OSM Wiki. Further information General information Bicycle routing Indoor mapping Elevators","title":"Troubleshooting"},{"location":"Troubleshooting-Routing/#troubleshooting-routing","text":"","title":"Troubleshooting Routing"},{"location":"Troubleshooting-Routing/#graph-builder-annotations","text":"When you build a graph, OTP may encounter clearly incorrect or ambiguous data, or may detect less severe but potentially problematic situations in the input data. Most such problems result in a \"graph builder annotation\" being added to the graph. Many annotations are logged to the console while the graph, but some that might yield too many messages may be recorded as annotations without being logged. At the end of the graph build process, OTP prints a summary of all the annotations it added to the graph, like the following: 11:35:57.515 INFO (Graph.java:970) Summary (number of each type of annotation): 11:35:57.518 INFO (Graph.java:976) TurnRestrictionBad - 560 11:35:57.518 INFO (Graph.java:976) TurnRestrictionException - 15 11:35:57.518 INFO (Graph.java:976) StopLinkedTooFar - 22 11:35:57.518 INFO (Graph.java:976) HopSpeedSlow - 22 11:35:57.518 INFO (Graph.java:976) Graphwide - 1 11:35:57.518 INFO (Graph.java:976) GraphConnectivity - 407 11:35:57.519 INFO (Graph.java:976) ParkAndRideUnlinked - 1 11:35:57.519 INFO (Graph.java:976) StopNotLinkedForTransfers - 31 11:35:57.519 INFO (Graph.java:976) NoFutureDates - 1 The full set of annotations can be written out to an HTML report for closer inspection. To enable the creation of these (potentially voluminous) HTML reports, add \"htmlAnnotations\" : true to your graph builder JSON configuration. If the graph is saved to a file, these annotations are saved with it and can be examined later. Currently the only tool for doing this is the \"Graph Visualizer\", which is not particularly well maintained and is intended for use by software developers familiar with OTP who can patch up the code as needed.","title":"Graph Builder Annotations"},{"location":"Troubleshooting-Routing/#debug-layers","text":"OpenTripplanner has option to ease debugging problems with graph. Older option is graph visualizer. Which you can enable with --visualize parameter instead of --server when starting OTP. There you can see whole graph. You can click on edges and vertices and see the metadata. It is useful to see if street has expected options. And if connections are where they are expected. It can be hard to use on large graphs since, whole graph is displayed at once. And it can be hard to search for specific streets since only street graph is shown without the rest of information. Another option is to use debug layers, which shows extra layers on top of normal map. To enable them you need to add ?debug_layers=true to URL. For example http://localhost:8080/?debug_layers=true . This adds debug layers to layer choosing dialog. Currently you can choose between: Wheelchair access (which colors street edges red if they don't allow wheelchair or green otherwise) Bike Safety (colors street edges based on how good are for cycling [smaller is better]) Traversal permissions (colors street edges based on what types of transit modes are allowed to travel on them (Pedestrian, cycling, car are currently supported)) Traversal permissions layer also draws links from transit stops/bike rentals and P+R to graph. And also draws transit stops, bike rentals and P+R vertices with different color.","title":"Debug layers"},{"location":"Troubleshooting-Routing/#interpretation-traversal-permissions-layer","text":"A sample traversal permissions layer looks like the following * Yellow lines is the link between a stop and the street graph. * Grey lines are streets one can travel with the mode walk, bike, or car * Green lines are paths one can travel with the mode walk only * Red lines are streets one can travel with the mode car only * Grey dots vertices where edges are connected. If two edges are crossing w/o a vertice at the intersection point, users will not be able to go from one street to the other. But this can be valid in case of over/under pass for example. If it's an error, it's usually caused by improperly connected OSM data (a shared OSM node is required).","title":"Interpretation Traversal permissions layer"},{"location":"Troubleshooting-Routing/#openstreetmap-data","text":"","title":"OpenStreetMap Data"},{"location":"Troubleshooting-Routing/#tags-affecting-permissions","text":"Access tags (such as bicycle/foot = yes/no/designated) can be used to override default graph-building parameters. As a default, foot and bicycle traffic is ''not'' allowed on highway=trunk , highway=trunk_link , highway=motorway , highway=motorway_link , or highway=construction . Both are allowed on highway=pedestrian , highway=cycleway , and highway=footway . Finally, bicycles are not allowed on highway=footway when any of the following tags appear on a footway: footway=sidewalk , public_transport=platform , or railway=platform . Other access tags (such as access=no and access=private affect routing as well, and can be overridden similarly. While access=no prohibits all traffic, access=private disallows through traffic. See osmWayPropertySet config attribute","title":"Tags Affecting Permissions"},{"location":"Troubleshooting-Routing/#railway-platforms","text":"OTP users in Helsinki have documented their best practices for coding railway platforms in OpenStreetMap. These guidelines are available in the OSM Wiki.","title":"Railway Platforms"},{"location":"Troubleshooting-Routing/#further-information","text":"General information Bicycle routing Indoor mapping Elevators","title":"Further information"},{"location":"Visual-Identity/","text":"OpenTripPlanner Visual Identity This is the OpenTripPlanner logo in scalable vector format, with knockout transparency: Here is a link to this SVG logo as a downloadable file . This is the raw SVG XML source code: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"> <svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"512px\" height=\"512px\" viewBox=\"0 0 125.333 125.334\" xml:space=\"preserve\"> <path fill=\"#2179BF\" d=\"M62.668,0C33.83,0,9.559,19.483,2.258,46l72.681-0.003c4.729-0.011,8.555-3.837,8.561-8.568 c-0.006-4.729-3.831-8.555-8.561-8.559c-4.731,0.004-8.557,3.83-8.564,8.559v4.592h-13.7v-4.592 c0-12.294,9.962-22.261,22.265-22.263c12.298,0.002,22.262,9.969,22.266,22.263c-0.003,12.3-9.968,22.264-22.266,22.271H0.074 C0.028,60.684,0,61.671,0,62.666c0,34.611,28.057,62.668,62.668,62.668c34.609,0,62.665-28.057,62.665-62.668 C125.333,28.057,97.277,0,62.668,0 M92.222,85.667v-3.473v-4.86l-47.058,0.003c-4.729,0.011-8.556,3.837-8.561,8.568 c0.005,4.728,3.831,8.555,8.561,8.559c4.731-0.004,8.558-3.831,8.565-8.559v-4.592h13.699v4.592 c0,12.294-9.961,22.261-22.265,22.263c-12.298-0.002-22.26-9.969-22.264-22.263c0.002-12.3,9.966-22.264,22.264-22.271h47.058V56.12 l21.712,14.775L92.222,85.667z\"/> </svg> This concept behind this logo design was \"infinite roads\". Besides the clear references to movement and wayfinding through a transportation network, it (somewhat subliminally) contains the letters O T and P. This design is more geometric and austere than our previous logo, which makes it readily recognizable in a crowd of small app icons, bookmarks, or favicons. It also channels the high modern logos and 1970s supergraphics that were the visual style of public transport for a generation. The color of the logo in the RGB colorspace is #2179BF . The name of the OpenTripPlanner project is written in CamelCase: capital letters at the beginning of each word, with no spaces between the words. For the logotype we do not strictly adhere to a standard typeface. The OTP website just uses the CSS declarations font: 30pt helvetica, sans-serif; font-weight: bold; . The OpenTripPlanner logo was created by Brooklyn-based cartographer and graphic designer Kate Chanba , who has also done extensive work on transit system maps.","title":"Visual Identity"},{"location":"Visual-Identity/#opentripplanner-visual-identity","text":"This is the OpenTripPlanner logo in scalable vector format, with knockout transparency: Here is a link to this SVG logo as a downloadable file . This is the raw SVG XML source code: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"> <svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"512px\" height=\"512px\" viewBox=\"0 0 125.333 125.334\" xml:space=\"preserve\"> <path fill=\"#2179BF\" d=\"M62.668,0C33.83,0,9.559,19.483,2.258,46l72.681-0.003c4.729-0.011,8.555-3.837,8.561-8.568 c-0.006-4.729-3.831-8.555-8.561-8.559c-4.731,0.004-8.557,3.83-8.564,8.559v4.592h-13.7v-4.592 c0-12.294,9.962-22.261,22.265-22.263c12.298,0.002,22.262,9.969,22.266,22.263c-0.003,12.3-9.968,22.264-22.266,22.271H0.074 C0.028,60.684,0,61.671,0,62.666c0,34.611,28.057,62.668,62.668,62.668c34.609,0,62.665-28.057,62.665-62.668 C125.333,28.057,97.277,0,62.668,0 M92.222,85.667v-3.473v-4.86l-47.058,0.003c-4.729,0.011-8.556,3.837-8.561,8.568 c0.005,4.728,3.831,8.555,8.561,8.559c4.731-0.004,8.558-3.831,8.565-8.559v-4.592h13.699v4.592 c0,12.294-9.961,22.261-22.265,22.263c-12.298-0.002-22.26-9.969-22.264-22.263c0.002-12.3,9.966-22.264,22.264-22.271h47.058V56.12 l21.712,14.775L92.222,85.667z\"/> </svg> This concept behind this logo design was \"infinite roads\". Besides the clear references to movement and wayfinding through a transportation network, it (somewhat subliminally) contains the letters O T and P. This design is more geometric and austere than our previous logo, which makes it readily recognizable in a crowd of small app icons, bookmarks, or favicons. It also channels the high modern logos and 1970s supergraphics that were the visual style of public transport for a generation. The color of the logo in the RGB colorspace is #2179BF . The name of the OpenTripPlanner project is written in CamelCase: capital letters at the beginning of each word, with no spaces between the words. For the logotype we do not strictly adhere to a standard typeface. The OTP website just uses the CSS declarations font: 30pt helvetica, sans-serif; font-weight: bold; . The OpenTripPlanner logo was created by Brooklyn-based cartographer and graphic designer Kate Chanba , who has also done extensive work on transit system maps.","title":"OpenTripPlanner Visual Identity"}]}